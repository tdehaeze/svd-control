#+TITLE: Diagonal control using the SVD and the Jacobian Matrix
:DRAWER:
#+STARTUP: overview

#+LANGUAGE: en
#+EMAIL: dehaeze.thomas@gmail.com
#+AUTHOR: Dehaeze Thomas

#+HTML_LINK_HOME: ../index.html
#+HTML_LINK_UP:   ../index.html

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://research.tdehaeze.xyz/css/style.css"/>
#+HTML_HEAD: <script type="text/javascript" src="https://research.tdehaeze.xyz/js/script.js"></script>

#+LaTeX_CLASS: scrreprt
#+LaTeX_HEADER_EXTRA: \input{preamble.tex}

#+HTML_MATHJAX: align: center tagside: right font: TeX

#+PROPERTY: header-args:matlab  :session *MATLAB*
#+PROPERTY: header-args:matlab+ :comments org
#+PROPERTY: header-args:matlab+ :results none
#+PROPERTY: header-args:matlab+ :exports both
#+PROPERTY: header-args:matlab+ :eval no-export
#+PROPERTY: header-args:matlab+ :output-dir figs
#+PROPERTY: header-args:matlab+ :tangle no
#+PROPERTY: header-args:matlab+ :mkdirp yes

#+PROPERTY: header-args:shell  :eval no-export

#+PROPERTY: header-args:latex  :headers '("\\usepackage{tikz}" "\\usepackage{import}" "\\import{$HOME/Cloud/tikz/org/}{config.tex}")
#+PROPERTY: header-args:latex+ :imagemagick t :fit yes
#+PROPERTY: header-args:latex+ :iminoptions -scale 100% -density 150
#+PROPERTY: header-args:latex+ :imoutoptions -quality 100
#+PROPERTY: header-args:latex+ :results file raw replace
#+PROPERTY: header-args:latex+ :buffer no
#+PROPERTY: header-args:latex+ :eval no-export
#+PROPERTY: header-args:latex+ :exports results
#+PROPERTY: header-args:latex+ :mkdirp yes
#+PROPERTY: header-args:latex+ :output-dir figs
#+PROPERTY: header-args:latex+ :post pdf2svg(file=*this*, ext="png")
:END:

#+begin_export html
  <hr>
  <p>This report is also available as a <a href="./svd-control.pdf">pdf</a>.</p>
  <hr>
#+end_export

* Introduction                                                        :ignore:

In this document, the use of the Jacobian matrix and the Singular Value Decomposition to render a physical plant diagonal dominant is studied.
Then, a diagonal controller is used.

These two methods are tested on two plants:
- In Section [[sec:gravimeter]] on a 3-DoF gravimeter
- In Section [[sec:stewart_platform]] on a 6-DoF Stewart platform

* Gravimeter - Simscape Model
:PROPERTIES:
:header-args:matlab+: :tangle gravimeter/script.m
:END:
<<sec:gravimeter>>

** Introduction

In this part, diagonal control using both the SVD and the Jacobian matrices are applied on a gravimeter model:
- Section [[sec:gravimeter_model]]: the model is described and its parameters are defined.
- Section [[sec:gravimeter_identification]]: the plant dynamics from the actuators to the sensors is computed from a Simscape model.
- Section [[sec:gravimeter_jacobian_decoupling]]: the plant is decoupled using the Jacobian matrices.
- Section [[sec:gravimeter_svd_decoupling]]: the Singular Value Decomposition is performed on a real approximation of the plant transfer matrix and further use to decouple the system.
- Section [[sec:gravimeter_gershgorin_radii]]: the effectiveness of the decoupling is computed using the Gershorin radii
- Section [[sec:gravimeter_rga]]: the effectiveness of the decoupling is computed using the Relative Gain Array
- Section [[sec:gravimeter_decoupled_plant]]: the obtained decoupled plants are compared
- Section [[sec:gravimeter_diagonal_control]]: the diagonal controller is developed
- Section [[sec:gravimeter_closed_loop_results]]: the obtained closed-loop performances for the two methods are compared
- Section [[sec:robustness_actuator_position]]: the robustness to a change of actuator position is evaluated
- Section [[sec:choice_jacobian_reference]]: the choice of the reference frame for the evaluation of the Jacobian is discussed
- Section [[sec:decoupling_performances]]: the decoupling performances of SVD is evaluated for a low damped and an highly damped system

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

#+begin_src matlab :tangle no
addpath('gravimeter');
#+end_src

#+begin_src matlab
freqs = logspace(-1, 3, 1000);
#+end_src

** Gravimeter Model - Parameters
<<sec:gravimeter_model>>

#+begin_src matlab :exports none
open('gravimeter.slx')
#+end_src

The model of the gravimeter is schematically shown in Figure [[fig:gravimeter_model]].

#+name: fig:gravimeter_model
#+caption: Model of the gravimeter
[[file:figs/gravimeter_model.png]]

#+name: fig:leg_model
#+caption: Model of the struts
[[file:figs/leg_model.png]]

The parameters used for the simulation are the following:
#+begin_src matlab
l  = 1.0; % Length of the mass [m]
h  = 1.7; % Height of the mass [m]

la = l/2; % Position of Act. [m]
ha = h/2; % Position of Act. [m]

m = 400; % Mass [kg]
I = 115; % Inertia [kg m^2]

k = 15e3; % Actuator Stiffness [N/m]
c = 2e1; % Actuator Damping [N/(m/s)]

deq = 0.2; % Length of the actuators [m]

g = 0; % Gravity [m/s2]
#+end_src

** System Identification
<<sec:gravimeter_identification>>

#+begin_src matlab
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'F1', 'F2', 'F3'};
G.OutputName = {'Ax1', 'Ay1', 'Ax2', 'Ay2'};
#+end_src

The inputs and outputs of the plant are shown in Figure [[fig:gravimeter_plant_schematic]].

More precisely there are three inputs (the three actuator forces):
\begin{equation}
  \bm{\tau} = \begin{bmatrix}\tau_1 \\ \tau_2 \\ \tau_2 \end{bmatrix}
\end{equation}
And 4 outputs (the two 2-DoF accelerometers):
\begin{equation}
  \bm{a} = \begin{bmatrix} a_{1x} \\ a_{1y} \\ a_{2x} \\ a_{2y} \end{bmatrix}
\end{equation}

#+begin_src latex :file gravimeter_plant_schematic.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};

  % Connections and labels
  \draw[<-] (G.west) -- ++(-2.0, 0) node[above right]{$\bm{\tau} = \begin{bmatrix}\tau_1 \\ \tau_2 \\ \tau_2 \end{bmatrix}$};
  \draw[->] (G.east) -- ++( 2.0, 0)  node[above left]{$\bm{a} = \begin{bmatrix} a_{1x} \\ a_{1y} \\ a_{2x} \\ a_{2y} \end{bmatrix}$};
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_plant_schematic
#+caption: Schematic of the gravimeter plant
#+RESULTS:
[[file:figs/gravimeter_plant_schematic.png]]

We can check the poles of the plant:
#+begin_src matlab :results value replace :exports results
pole(G)
#+end_src

#+RESULTS:
| -0.12243+13.551i   |
| -0.12243-13.551i   |
| -0.05+8.6601i      |
| -0.05-8.6601i      |
| -0.0088785+3.6493i |
| -0.0088785-3.6493i |

As expected, the plant as 6 states (2 translations + 1 rotation)
#+begin_src matlab :results output replace
size(G)
#+end_src

#+RESULTS:
: State-space model with 4 outputs, 3 inputs, and 6 states.

The bode plot of all elements of the plant are shown in Figure [[fig:open_loop_tf]].

#+begin_src matlab :exports none
figure;
tiledlayout(4, 3, 'TileSpacing', 'None', 'Padding', 'None');

for out_i = 1:4
    for in_i = 1:3
        nexttile;
        plot(freqs, abs(squeeze(freqresp(G(out_i,in_i), freqs, 'Hz'))), '-');
        set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
        xlim([1e-1, 2e1]); ylim([1e-4, 1e0]);

        if in_i == 1
            ylabel('Amplitude [$\frac{m/s^2}{N}$]')
        else
            set(gca, 'YTickLabel',[]);
        end

        if out_i == 4
            xlabel('Frequency [Hz]')
        else
            set(gca, 'XTickLabel',[]);
        end
    end
end
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/open_loop_tf.pdf', 'width', 'full', 'height', 'full');
#+end_src

#+name: fig:open_loop_tf
#+attr_latex: :width \linewidth
#+caption: Open Loop Transfer Function from 3 Actuators to 4 Accelerometers
#+RESULTS:
[[file:figs/open_loop_tf.png]]

** Decoupling using the Jacobian
<<sec:gravimeter_jacobian_decoupling>>

Consider the control architecture shown in Figure [[fig:gravimeter_decouple_jacobian]].

The Jacobian matrix $J_{\tau}$ is used to transform forces applied by the three actuators into forces/torques applied on the gravimeter at its center of mass:
\begin{equation}
  \begin{bmatrix} \tau_1 \\ \tau_2 \\ \tau_3 \end{bmatrix} = J_{\tau}^{-T} \begin{bmatrix} F_x \\ F_y \\ M_z \end{bmatrix}
\end{equation}

The Jacobian matrix $J_{a}$ is used to compute the vertical acceleration, horizontal acceleration and rotational acceleration of the mass with respect to its center of mass:
\begin{equation}
  \begin{bmatrix} a_x \\ a_y \\ a_{R_z} \end{bmatrix} = J_{a}^{-1} \begin{bmatrix} a_{x1} \\ a_{y1} \\ a_{x2} \\ a_{y2} \end{bmatrix}
\end{equation}

We thus define a new plant as defined in Figure [[fig:gravimeter_decouple_jacobian]].
\[ \bm{G}_x(s) = J_a^{-1} \bm{G}(s) J_{\tau}^{-T} \]

$\bm{G}_x(s)$ correspond to the $3 \times 3$ transfer function matrix from forces and torques applied to the gravimeter at its center of mass to the absolute acceleration of the gravimeter's center of mass (Figure [[fig:gravimeter_decouple_jacobian]]).

#+begin_src latex :file gravimeter_decouple_jacobian.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\tau}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{a}^{-1}$};

  % Connections and labels
  \draw[<-] (Jt.west) -- ++(-2.5, 0) node[above right]{$\bm{\mathcal{F}} = \begin{bmatrix}F_x \\ F_y \\ M_z \end{bmatrix}$};
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{a}$};
  \draw[->] (Ja.east) -- ++( 2.6, 0)  node[above left]{$\bm{\mathcal{A}} = \begin{bmatrix}a_x \\ a_y \\ a_{R_z} \end{bmatrix}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_x$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_decouple_jacobian
#+caption: Decoupled plant $\bm{G}_x$ using the Jacobian matrix $J$
#+RESULTS:
[[file:figs/gravimeter_decouple_jacobian.png]]

The Jacobian corresponding to the sensors and actuators are defined below:
#+begin_src matlab
Ja = [1 0 -h/2
      0 1  l/2
      1 0  h/2
      0 1  0];

Jt = [1 0 -ha
      0 1  la
      0 1 -la];
#+end_src

And the plant $\bm{G}_x$ is computed:
#+begin_src matlab
Gx = pinv(Ja)*G*pinv(Jt');
Gx.InputName  = {'Fx', 'Fy', 'Mz'};
Gx.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

#+begin_src matlab :results output replace :exports results
size(Gx)
#+end_src

#+RESULTS:
: size(Gx)
: State-space model with 3 outputs, 3 inputs, and 6 states.

The diagonal and off-diagonal elements of $G_x$ are shown in Figure [[fig:gravimeter_jacobian_plant]].

It is shown at the system is:
- decoupled at high frequency thanks to a diagonal mass matrix (the Jacobian being evaluated at the center of mass of the payload)
- coupled at low frequency due to the non-diagonal terms in the stiffness matrix, especially the term corresponding to a coupling between a force in the x direction to a rotation around z (due to the torque applied by the stiffness 1).

The choice of the frame in this the Jacobian is evaluated is discussed in Section [[sec:choice_jacobian_reference]].

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gx(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gx(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_x(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gx(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_x(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southeast');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_jacobian_plant.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_jacobian_plant
#+caption: Diagonal and off-diagonal elements of $G_x$
#+RESULTS:
[[file:figs/gravimeter_jacobian_plant.png]]

** Decoupling using the SVD
<<sec:gravimeter_svd_decoupling>>

In order to decouple the plant using the SVD, first a real approximation of the plant transfer function matrix as the crossover frequency is required.

Let's compute a real approximation of the complex matrix $H_1$ which corresponds to the the transfer function $G(j\omega_c)$ from forces applied by the actuators to the measured acceleration of the top platform evaluated at the frequency $\omega_c$.
#+begin_src matlab
wc = 2*pi*10; % Decoupling frequency [rad/s]

H1 = evalfr(G, j*wc);
#+end_src

The real approximation is computed as follows:
#+begin_src matlab
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(H1, {}, {}, ' %.2g ');
#+end_src

#+caption: Real approximate of $G$ at the decoupling frequency $\omega_c$
#+RESULTS:
|  0.0092 | -0.0039 |  0.0039 |
| -0.0039 |  0.0048 | 0.00028 |
|  -0.004 |  0.0038 | -0.0038 |
| 8.4e-09 |  0.0025 |  0.0025 |


Now, the Singular Value Decomposition of $H_1$ is performed:
\[ H_1 = U \Sigma V^H \]

#+begin_src matlab
[U,S,V] = svd(H1);
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(U, {}, {}, ' %.2f ');
#+end_src

#+caption: $U$ matrix
#+RESULTS:
| -0.78 |  0.26 | -0.53 |  -0.2 |
|   0.4 |  0.61 | -0.04 | -0.68 |
|  0.48 | -0.14 | -0.85 |   0.2 |
|  0.03 |  0.73 |  0.06 |  0.68 |

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(V, {}, {}, ' %.2f ');
#+end_src

#+caption: $V$ matrix
#+RESULTS:
| -0.79 | 0.11 |  -0.6 |
|  0.51 | 0.67 | -0.54 |
| -0.35 | 0.73 |  0.59 |

The obtained matrices $U$ and $V$ are used to decouple the system as shown in Figure [[fig:gravimeter_decouple_svd]].

#+begin_src latex :file gravimeter_decouple_svd.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};

  \node[block, left=0.6 of G.west] (V) {$V^{-T}$};
  \node[block, right=0.6 of G.east] (U) {$U^{-1}$};

  % Connections and labels
  \draw[<-] (V.west) -- ++(-1.0, 0) node[above right]{$u$};
  \draw[->] (V.east) -- (G.west) node[above left]{$\tau$};
  \draw[->] (G.east) -- (U.west) node[above left]{$a$};
  \draw[->] (U.east) -- ++( 1.0, 0) node[above left]{$y$};

  \begin{scope}[on background layer]
    \node[fit={(V.south west) (G.north-|U.east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gsvd) {};
    \node[below right] at (Gsvd.north west) {$\bm{G}_{SVD}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_decouple_svd
#+caption: Decoupled plant $\bm{G}_{SVD}$ using the Singular Value Decomposition
#+RESULTS:
[[file:figs/gravimeter_decouple_svd.png]]

The decoupled plant is then:
\[ \bm{G}_{SVD}(s) = U^{-1} \bm{G}(s) V^{-H} \]

#+begin_src matlab
Gsvd = inv(U)*G*inv(V');
#+end_src

#+begin_src matlab :results output replace :exports results
size(Gsvd)
#+end_src

#+RESULTS:
: size(Gsvd)
: State-space model with 4 outputs, 3 inputs, and 6 states.

The 4th output (corresponding to the null singular value) is discarded, and we only keep the $3 \times 3$ plant:
#+begin_src matlab
Gsvd = Gsvd(1:3, 1:3);
#+end_src

The diagonal and off-diagonal elements of the "SVD" plant are shown in Figure [[fig:gravimeter_svd_plant]].
#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_x(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvd(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_x(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southwest', 'FontSize', 8);
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_svd_plant.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_svd_plant
#+caption: Diagonal and off-diagonal elements of $G_{svd}$
#+RESULTS:
[[file:figs/gravimeter_svd_plant.png]]

** Verification of the decoupling using the "Gershgorin Radii"
<<sec:gravimeter_gershgorin_radii>>

The "Gershgorin Radii" is computed for the coupled plant $G(s)$, for the "Jacobian plant" $G_x(s)$ and the "SVD Decoupled Plant" $G_{SVD}(s)$:

The "Gershgorin Radii" of a matrix $S$ is defined by:
\[ \zeta_i(j\omega) = \frac{\sum\limits_{j\neq i}|S_{ij}(j\omega)|}{|S_{ii}(j\omega)|} \]

#+begin_src matlab :exports none
% Gershgorin Radii for the coupled plant:
Gr_coupled = zeros(length(freqs), size(G,2));
H = abs(squeeze(freqresp(G, freqs, 'Hz')));
for out_i = 1:size(G,2)
    Gr_coupled(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end

% Gershgorin Radii for the decoupled plant using SVD:
Gr_decoupled = zeros(length(freqs), size(Gsvd,2));
H = abs(squeeze(freqresp(Gsvd, freqs, 'Hz')));
for out_i = 1:size(Gsvd,2)
    Gr_decoupled(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end

% Gershgorin Radii for the decoupled plant using the Jacobian:
Gr_jacobian = zeros(length(freqs), size(Gx,2));
H = abs(squeeze(freqresp(Gx, freqs, 'Hz')));
for out_i = 1:size(Gx,2)
    Gr_jacobian(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end
#+end_src

#+begin_src matlab :exports results
figure;
hold on;
plot(freqs, Gr_coupled(:,1), 'DisplayName', 'Coupled');
plot(freqs, Gr_decoupled(:,1), 'DisplayName', 'SVD');
plot(freqs, Gr_jacobian(:,1), 'DisplayName', 'Jacobian');
for in_i = 2:3
    set(gca,'ColorOrderIndex',1)
    plot(freqs, Gr_coupled(:,in_i), 'HandleVisibility', 'off');
    set(gca,'ColorOrderIndex',2)
    plot(freqs, Gr_decoupled(:,in_i), 'HandleVisibility', 'off');
    set(gca,'ColorOrderIndex',3)
    plot(freqs, Gr_jacobian(:,in_i), 'HandleVisibility', 'off');
end
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
hold off;
xlabel('Frequency (Hz)'); ylabel('Gershgorin Radii')
legend('location', 'southwest');
ylim([1e-4, 1e2]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_gershgorin_radii.pdf', 'eps', true, 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_gershgorin_radii
#+caption: Gershgorin Radii of the Coupled and Decoupled plants
#+RESULTS:
[[file:figs/gravimeter_gershgorin_radii.png]]

** Verification of the decoupling using the "Relative Gain Array"
<<sec:gravimeter_rga>>

The relative gain array (RGA) is defined as:
\begin{equation}
  \Lambda\big(G(s)\big) = G(s) \times \big( G(s)^{-1} \big)^T
\end{equation}
where $\times$ denotes an element by element multiplication and $G(s)$ is an $n \times n$ square transfer matrix.

The obtained RGA elements are shown in Figure [[fig:gravimeter_rga]].

#+begin_src matlab :exports none
% Relative Gain Array for the decoupled plant using SVD:
RGA_svd = zeros(length(freqs), size(Gsvd,1), size(Gsvd,2));
Gsvd_inv = inv(Gsvd);
for f_i = 1:length(freqs)
    RGA_svd(f_i, :, :) = abs(evalfr(Gsvd, j*2*pi*freqs(f_i)).*evalfr(Gsvd_inv, j*2*pi*freqs(f_i))');
end

% Relative Gain Array for the decoupled plant using the Jacobian:
RGA_x = zeros(length(freqs), size(Gx,1), size(Gx,2));
Gx_inv = inv(Gx);
for f_i = 1:length(freqs)
    RGA_x(f_i, :, :) = abs(evalfr(Gx, j*2*pi*freqs(f_i)).*evalfr(Gx_inv, j*2*pi*freqs(f_i))');
end
#+end_src

#+begin_src matlab :exports none
figure;
tiledlayout(1, 2, 'TileSpacing', 'None', 'Padding', 'None');

ax1 = nexttile;
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, RGA_svd(:, i_out, i_in), '--', 'color', [0 0 0 0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, RGA_svd(:, 1, 2), '--', 'color', [0 0 0 0.2], ...
     'DisplayName', '$RGA_{SVD}(i,j),\ i \neq j$');

plot(freqs, RGA_svd(:, 1, 1), 'k-', ...
     'DisplayName', '$RGA_{SVD}(i,i)$');
for ch_i = 1:3
    plot(freqs, RGA_svd(:, ch_i, ch_i), 'k-', ...
         'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); xlabel('Frequency [Hz]');
legend('location', 'southwest');

ax2 = nexttile;
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, RGA_x(:, i_out, i_in), '--', 'color', [0 0 0 0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, RGA_x(:, 1, 2), '--', 'color', [0 0 0 0.2], ...
     'DisplayName', '$RGA_{X}(i,j),\ i \neq j$');

plot(freqs, RGA_x(:, 1, 1), 'k-', ...
     'DisplayName', '$RGA_{X}(i,i)$');
for ch_i = 1:3
    plot(freqs, RGA_x(:, ch_i, ch_i), 'k-', ...
         'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); set(gca, 'YTickLabel',[]);
legend('location', 'southwest');

linkaxes([ax1,ax2],'y');
ylim([1e-5, 1e1]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_rga.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:gravimeter_rga
#+caption: Obtained norm of RGA elements for the SVD decoupled plant and the Jacobian decoupled plant
#+RESULTS:
[[file:figs/gravimeter_rga.png]]

The RGA-number is also a measure of diagonal dominance:
\begin{equation}
  \text{RGA-number} = \| \Lambda(G) - I \|_\text{sum}
\end{equation}

#+begin_src matlab :exports none
% Relative Gain Array for the decoupled plant using SVD:
RGA_svd = zeros(size(Gsvd,1), size(Gsvd,2), length(freqs));
Gsvd_inv = inv(Gsvd);
for f_i = 1:length(freqs)
    RGA_svd(:, :, f_i) = abs(evalfr(Gsvd, j*2*pi*freqs(f_i)).*evalfr(Gsvd_inv, j*2*pi*freqs(f_i))');
end

% Relative Gain Array for the decoupled plant using the Jacobian:
RGA_x = zeros(size(Gx,1), size(Gx,2), length(freqs));
Gx_inv = inv(Gx);
for f_i = 1:length(freqs)
    RGA_x(:, :, f_i) = abs(evalfr(Gx, j*2*pi*freqs(f_i)).*evalfr(Gx_inv, j*2*pi*freqs(f_i))');
end
#+end_src

#+begin_src matlab :exports none
RGA_num_svd = squeeze(sum(sum(RGA_svd - eye(3))));
RGA_num_x = squeeze(sum(sum(RGA_x - eye(3))));

figure;
hold on;
plot(freqs, RGA_num_svd)
plot(freqs, RGA_num_x)
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('RGA-Number');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_rga_num.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_rga_num
#+caption: RGA-Number for the Gravimeter
#+RESULTS:
[[file:figs/gravimeter_rga_num.png]]

** Obtained Decoupled Plants
<<sec:gravimeter_decoupled_plant>>

The bode plot of the diagonal and off-diagonal elements of $G_{SVD}$ are shown in Figure [[fig:gravimeter_decoupled_plant_svd]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvd(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.5], ...
     'DisplayName', '$G_{SVD}(i,j),\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for ch_i = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvd(ch_i, ch_i), freqs, 'Hz'))), ...
         'DisplayName', sprintf('$G_{SVD}(%i,%i)$', ch_i, ch_i));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'southwest');
ylim([1e-8, 1e0])

% Phase
ax2 = nexttile;
hold on;
for ch_i = 1:3
    plot(freqs, 180/pi*angle(squeeze(freqresp(Gsvd(ch_i, ch_i), freqs, 'Hz'))));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([-180, 180]);
yticks([-180:90:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_decoupled_plant_svd.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:gravimeter_decoupled_plant_svd
#+caption: Decoupled Plant using SVD
#+RESULTS:
[[file:figs/gravimeter_decoupled_plant_svd.png]]

Similarly, the bode plots of the diagonal elements and off-diagonal elements of the decoupled plant $G_x(s)$ using the Jacobian are shown in Figure [[fig:gravimeter_decoupled_plant_jacobian]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gx(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gx(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.5], ...
     'DisplayName', '$G_x(i,j),\ i \neq j$');
set(gca,'ColorOrderIndex',1)
plot(freqs, abs(squeeze(freqresp(Gx(1, 1), freqs, 'Hz'))), 'DisplayName', '$G_x(1,1) = A_x/F_x$');
plot(freqs, abs(squeeze(freqresp(Gx(2, 2), freqs, 'Hz'))), 'DisplayName', '$G_x(2,2) = A_y/F_y$');
plot(freqs, abs(squeeze(freqresp(Gx(3, 3), freqs, 'Hz'))), 'DisplayName', '$G_x(3,3) = R_z/M_z$');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'southwest');
ylim([1e-8, 1e0])

% Phase
ax2 = nexttile;
hold on;
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx(1, 1), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx(2, 2), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx(3, 3), freqs, 'Hz'))));
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([-180, 180]);
yticks([0:45:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_decoupled_plant_jacobian.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:gravimeter_decoupled_plant_jacobian
#+caption: Gravimeter Platform Plant from forces (resp. torques) applied by the legs to the acceleration (resp. angular acceleration) of the platform as well as all the coupling terms between the two (non-diagonal terms of the transfer function matrix)
#+RESULTS:
[[file:figs/gravimeter_decoupled_plant_jacobian.png]]

** Diagonal Controller
<<sec:gravimeter_diagonal_control>>
The control diagram for the centralized control is shown in Figure [[fig:centralized_control_gravimeter]].

The controller $K_c$ is "working" in an cartesian frame.
The Jacobian is used to convert forces in the cartesian frame to forces applied by the actuators.

#+begin_src latex :file centralized_control_gravimeter.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\tau}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{a}^{-1}$};
  \node[block, left=1.2 of Jt] (K) {$K_c$};

  % Connections and labels
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{a}$};
  \draw[->] (Ja.east) -- ++(1.4, 0);
  \draw[->] ($(Ja.east) + (0.8, 0)$) node[branch]{} node[above]{$\bm{\mathcal{A}}$} -- ++(0, -1.2) -| ($(K.west) + (-0.6, 0)$) -- (K.west);
  \draw[->] (K.east) -- (Jt.west) node[above left]{$\bm{\mathcal{F}}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_x$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:centralized_control_gravimeter
#+caption: Control Diagram for the Centralized control
#+RESULTS:
[[file:figs/centralized_control_gravimeter.png]]

The SVD control architecture is shown in Figure [[fig:svd_control_gravimeter]].
The matrices $U$ and $V$ are used to decoupled the plant $G$.

#+begin_src latex :file svd_control_gravimeter.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};

  \node[block, left=0.6 of G.west] (V) {$V^{-T}$};
  \node[block, right=0.6 of G.east] (U) {$U^{-1}$};
  \node[block, left=1.2 of V] (K) {$K_c$};

  % Connections and labels
  \draw[->] (V.east) -- (G.west) node[above left]{$\tau$};
  \draw[->] (G.east) -- (U.west) node[above left]{$a$};
  \draw[->] (U.east) -- ++( 1.4, 0);
  \draw[->] ($(U.east) + (0.8, 0)$) node[branch]{} node[above]{$y$} -- ++(0, -1.2) -| ($(K.west) + (-0.6, 0)$) -- (K.west);
  \draw[->] (K.east) -- (V.west) node[above left]{$u$};

  \begin{scope}[on background layer]
    \node[fit={(V.south west) (G.north-|U.east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gsvd) {};
    \node[below right] at (Gsvd.north west) {$\bm{G}_{SVD}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:svd_control_gravimeter
#+caption: Control Diagram for the SVD control
#+RESULTS:
[[file:figs/svd_control_gravimeter.png]]


We choose the controller to be a low pass filter:
\[ K_c(s) = \frac{G_0}{1 + \frac{s}{\omega_0}} \]

$G_0$ is tuned such that the crossover frequency corresponding to the diagonal terms of the loop gain is equal to $\omega_c$

#+begin_src matlab
wc = 2*pi*10;  % Crossover Frequency [rad/s]
w0 = 2*pi*0.1; % Controller Pole [rad/s]
#+end_src

#+begin_src matlab
K_cen = diag(1./diag(abs(evalfr(Gx, j*wc))))*(1/abs(evalfr(1/(1 + s/w0), j*wc)))/(1 + s/w0);
L_cen = K_cen*Gx;
#+end_src

#+begin_src matlab
K_svd = diag(1./diag(abs(evalfr(Gsvd, j*wc))))*(1/abs(evalfr(1/(1 + s/w0), j*wc)))/(1 + s/w0);
L_svd = K_svd*Gsvd;
U_inv = inv(U);
#+end_src

The obtained diagonal elements of the loop gains are shown in Figure [[fig:gravimeter_comp_loop_gain_diagonal]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
plot(freqs, abs(squeeze(freqresp(L_svd(1, 1), freqs, 'Hz'))), 'DisplayName', '$L_{SVD}(i,i)$');
for i_in_out = 2:3
    set(gca,'ColorOrderIndex',1)
    plot(freqs, abs(squeeze(freqresp(L_svd(i_in_out, i_in_out), freqs, 'Hz'))), 'HandleVisibility', 'off');
end

set(gca,'ColorOrderIndex',2)
plot(freqs, abs(squeeze(freqresp(L_cen(1, 1), freqs, 'Hz'))), ...
     'DisplayName', '$L_{J}(i,i)$');
for i_in_out = 2:3
    set(gca,'ColorOrderIndex',2)
    plot(freqs, abs(squeeze(freqresp(L_cen(i_in_out, i_in_out), freqs, 'Hz'))), 'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'northwest');
ylim([5e-2, 2e3])

% Phase
ax2 = nexttile;
hold on;
for i_in_out = 1:3
    set(gca,'ColorOrderIndex',1)
    plot(freqs, 180/pi*angle(squeeze(freqresp(L_svd(i_in_out, i_in_out), freqs, 'Hz'))));
end
set(gca,'ColorOrderIndex',2)
for i_in_out = 1:3
    set(gca,'ColorOrderIndex',2)
    plot(freqs, 180/pi*angle(squeeze(freqresp(L_cen(i_in_out, i_in_out), freqs, 'Hz'))));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([-180, 180]);
yticks([-180:90:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_comp_loop_gain_diagonal.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:gravimeter_comp_loop_gain_diagonal
#+caption: Comparison of the diagonal elements of the loop gains for the SVD control architecture and the Jacobian one
#+RESULTS:
[[file:figs/gravimeter_comp_loop_gain_diagonal.png]]

** Closed-Loop system Performances
<<sec:gravimeter_closed_loop_results>>

Now the system is identified again with additional inputs and outputs:
- $x$, $y$ and $R_z$ ground motion
- $x$, $y$ and $R_z$ acceleration of the payload.

#+begin_src matlab
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/Dx'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Dy'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Rz'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 3, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'Dx', 'Dy', 'Rz', 'F1', 'F2', 'F3'};
G.OutputName = {'Ax', 'Ay', 'Arz', 'Ax1', 'Ay1', 'Ax2', 'Ay2'};
#+end_src

The loop is closed using the developed controllers.
#+begin_src matlab
G_cen = lft(G, -pinv(Jt')*K_cen*pinv(Ja));
G_svd = lft(G, -inv(V')*K_svd*U_inv(1:3, :));
#+end_src

Let's first verify the stability of the closed-loop systems:
#+begin_src matlab :results output replace text
isstable(G_cen)
#+end_src

#+RESULTS:
: ans =
:   logical
:    1

#+begin_src matlab :results output replace text
isstable(G_svd)
#+end_src

#+RESULTS:
: ans =
:   logical
:    1

The obtained transmissibility in Open-loop, for the centralized control as well as for the SVD control are shown in Figure [[fig:gravimeter_platform_simscape_cl_transmissibility]].

#+begin_src matlab :exports results
freqs = logspace(-2, 2, 1000);

figure;
tiledlayout(1, 3, 'TileSpacing', 'None', 'Padding', 'None');

ax1 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Ax','Dx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Open-Loop');
plot(freqs, abs(squeeze(freqresp(G_cen('Ax','Dx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Centralized');
plot(freqs, abs(squeeze(freqresp(G_svd('Ax','Dx')/s^2, freqs, 'Hz'))), '--', 'DisplayName', 'SVD');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Transmissibility'); xlabel('Frequency [Hz]');
title('$D_x/D_{w,x}$');
legend('location', 'southwest');

ax2 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Ay','Dy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Ay','Dy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Ay','Dy')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
set(gca, 'YTickLabel',[]); xlabel('Frequency [Hz]');
title('$D_y/D_{w,y}$');

ax3 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Arz','Rz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Arz','Rz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Arz','Rz')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
set(gca, 'YTickLabel',[]); xlabel('Frequency [Hz]');
title('$R_z/R_{w,z}$');

linkaxes([ax1,ax2,ax3],'xy');
xlim([freqs(1), freqs(end)]);
xlim([1e-2, 5e1]); ylim([1e-2, 1e1]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_platform_simscape_cl_transmissibility.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:gravimeter_platform_simscape_cl_transmissibility
#+caption: Obtained Transmissibility
#+RESULTS:
[[file:figs/gravimeter_platform_simscape_cl_transmissibility.png]]

#+begin_src matlab :exports results
freqs = logspace(-2, 2, 1000);

figure;
hold on;
for out_i = 1:3
    for in_i = out_i+1:3
        set(gca,'ColorOrderIndex',1)
        plot(freqs, abs(squeeze(freqresp(G(    out_i,in_i), freqs, 'Hz'))));
        set(gca,'ColorOrderIndex',2)
        plot(freqs, abs(squeeze(freqresp(G_cen(out_i,in_i), freqs, 'Hz'))));
        set(gca,'ColorOrderIndex',3)
        plot(freqs, abs(squeeze(freqresp(G_svd(out_i,in_i), freqs, 'Hz'))), '--');
    end
end
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Transmissibility'); xlabel('Frequency [Hz]');
ylim([1e-6, 1e3]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_cl_transmissibility_coupling.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_cl_transmissibility_coupling
#+caption: Obtain coupling terms of the transmissibility matrix
#+RESULTS:
[[file:figs/gravimeter_cl_transmissibility_coupling.png]]


** Robustness to a change of actuator position
<<sec:robustness_actuator_position>>

Let say we change the position of the actuators:
#+begin_src matlab
la = l/2*0.7; % Position of Act. [m]
ha = h/2*0.7; % Position of Act. [m]
#+end_src

#+begin_src matlab
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/Dx'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Dy'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Rz'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Abs_Motion'], 3, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'Dx', 'Dy', 'Rz', 'F1', 'F2', 'F3'};
G.OutputName = {'Ax', 'Ay', 'Arz', 'Ax1', 'Ay1', 'Ax2', 'Ay2'};
#+end_src

The loop is closed using the developed controllers.
#+begin_src matlab
G_cen_b = lft(G, -pinv(Jt')*K_cen*pinv(Ja));
G_svd_b = lft(G, -inv(V')*K_svd*U_inv(1:3, :));
#+end_src

The new plant is computed, and the centralized and SVD control architectures are applied using the previously computed Jacobian matrices and $U$ and $V$ matrices.

The closed-loop system are still stable in both cases, and the obtained transmissibility are equivalent as shown in Figure [[fig:gravimeter_transmissibility_offset_act]].

#+begin_src matlab :exports results
freqs = logspace(-2, 2, 1000);

figure;
tiledlayout(1, 3, 'TileSpacing', 'None', 'Padding', 'None');

ax1 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G_cen(      'Ax','Dx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Open-Loop');
plot(freqs, abs(squeeze(freqresp(G_cen_b('Ax','Dx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Centralized');
plot(freqs, abs(squeeze(freqresp(G_svd_b('Ax','Dx')/s^2, freqs, 'Hz'))), '--', 'DisplayName', 'SVD');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Transmissibility'); xlabel('Frequency [Hz]');
title('$D_x/D_{w,x}$');
legend('location', 'southwest');

ax2 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G_cen(      'Ay','Dy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen_b('Ay','Dy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd_b('Ay','Dy')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
set(gca, 'YTickLabel',[]); xlabel('Frequency [Hz]');
title('$D_y/D_{w,y}$');

ax3 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G_cen(      'Arz','Rz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen_b('Arz','Rz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd_b('Arz','Rz')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
set(gca, 'YTickLabel',[]); xlabel('Frequency [Hz]');
title('$R_z/R_{w,z}$');

linkaxes([ax1,ax2,ax3],'xy');
xlim([freqs(1), freqs(end)]);
xlim([1e-2, 5e1]); ylim([1e-2, 1e1]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_transmissibility_offset_act.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_transmissibility_offset_act
#+caption: Transmissibility for the initial CL system and when the position of  actuators are changed
#+RESULTS:
[[file:figs/gravimeter_transmissibility_offset_act.png]]

** Choice of the reference frame for Jacobian decoupling
<<sec:choice_jacobian_reference>>
*** Introduction                                                    :ignore:

If we want to decouple the system at low frequency (determined by the stiffness matrix), we have to compute the Jacobian at a point where the stiffness matrix is diagonal.
A displacement (resp. rotation) of the mass at this particular point should induce a *pure* force (resp. torque) on the same point due to stiffnesses in the system.
This can be verified by geometrical computations.


If we want to decouple the system at high frequency (determined by the mass matrix), we have tot compute the Jacobians at the Center of Mass of the suspended solid.
Similarly to the stiffness analysis, when considering only the inertia effects (neglecting the stiffnesses), a force (resp. torque) applied at this point (the center of mass) should induce a *pure* acceleration (resp. angular acceleration).


Ideally, we would like to have a decoupled mass matrix and stiffness matrix at the same time.
To do so, the actuators (springs) should be positioned such that the stiffness matrix is diagonal when evaluated at the CoM of the solid.

*** Decoupling of the mass matrix

#+name: fig:gravimeter_model_M
#+caption: Choice of {O} such that the Mass Matrix is Diagonal
[[file:figs/gravimeter_model_M.png]]

#+begin_src matlab
la = l/2; % Position of Act. [m]
ha = h/2; % Position of Act. [m]
#+end_src

#+begin_src matlab
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'F1', 'F2', 'F3'};
G.OutputName = {'Ax1', 'Ay1', 'Ax2', 'Ay2'};
#+end_src

Decoupling at the CoM (Mass decoupled)
#+begin_src matlab
JMa = [1 0 -h/2
       0 1  l/2
       1 0  h/2
       0 1  0];

JMt = [1 0 -ha
       0 1  la
       0 1 -la];
#+end_src

#+begin_src matlab
GM = pinv(JMa)*G*pinv(JMt');
GM.InputName  = {'Fx', 'Fy', 'Mz'};
GM.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(GM(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(GM(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_x(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(GM(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_x(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southeast');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/jac_decoupling_M.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:jac_decoupling_M
#+caption: Diagonal and off-diagonal elements of the decoupled plant
#+RESULTS:
[[file:figs/jac_decoupling_M.png]]

*** Decoupling of the stiffness matrix

#+name: fig:gravimeter_model_K
#+caption: Choice of {O} such that the Stiffness Matrix is Diagonal
[[file:figs/gravimeter_model_K.png]]

Decoupling at the point where K is diagonal (x = 0, y = -h/2 from the schematic {O} frame):
#+begin_src matlab
JKa = [1 0  0
       0 1 -l/2
       1 0 -h
       0 1  0];

JKt = [1 0  0
       0 1 -la
       0 1  la];
#+end_src

And the plant $\bm{G}_x$ is computed:
#+begin_src matlab
GK = pinv(JKa)*G*pinv(JKt');
GK.InputName  = {'Fx', 'Fy', 'Mz'};
GK.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(GK(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(GK(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_x(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(GK(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_x(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southeast');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/jac_decoupling_K.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:jac_decoupling_K
#+caption: Diagonal and off-diagonal elements of the decoupled plant
#+RESULTS:
[[file:figs/jac_decoupling_K.png]]

*** Combined decoupling of the mass and stiffness matrices

#+name: fig:gravimeter_model_KM
#+caption: Ideal location of the actuators such that both the mass and stiffness matrices are diagonal
[[file:figs/gravimeter_model_KM.png]]

To do so, the actuator position should be modified

#+begin_src matlab
la = l/2; % Position of Act. [m]
ha = 0; % Position of Act. [m]
#+end_src

#+begin_src matlab
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'F1', 'F2', 'F3'};
G.OutputName = {'Ax1', 'Ay1', 'Ax2', 'Ay2'};
#+end_src

#+begin_src matlab
JMa = [1 0 -h/2
       0 1  l/2
       1 0  h/2
       0 1  0];

JMt = [1 0 -ha
       0 1  la
       0 1 -la];
#+end_src

#+begin_src matlab
GKM = pinv(JMa)*G*pinv(JMt');
GKM.InputName  = {'Fx', 'Fy', 'Mz'};
GKM.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(GKM(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(GKM(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_x(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(GKM(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_x(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southeast');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/jac_decoupling_KM.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:jac_decoupling_KM
#+caption: Diagonal and off-diagonal elements of the decoupled plant
#+RESULTS:
[[file:figs/jac_decoupling_KM.png]]

*** Conclusion

Ideally, the mechanical system should be designed in order to have a decoupled stiffness matrix at the CoM of the solid.

If not the case, the system can either be decoupled as low frequency if the Jacobian are evaluated at a point where the stiffness matrix is decoupled.
Or it can be decoupled at high frequency if the Jacobians are evaluated at the CoM.

** SVD decoupling performances
<<sec:decoupling_performances>>
As the SVD is applied on a *real approximation* of the plant dynamics at a frequency $\omega_0$, it is foreseen that the effectiveness of the decoupling depends on the validity of the real approximation.

Let's do the SVD decoupling on a plant that is mostly real (low damping) and one with a large imaginary part (larger damping).

Start with small damping, the obtained diagonal and off-diagonal terms are shown in Figure [[fig:gravimeter_svd_low_damping]].
#+begin_src matlab
c = 2e1; % Actuator Damping [N/(m/s)]
#+end_src

#+begin_src matlab :exports none
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'F1', 'F2', 'F3'};
G.OutputName = {'Ax1', 'Ay1', 'Ax2', 'Ay2'};

wc = 2*pi*10; % Decoupling frequency [rad/s]
H1 = evalfr(G, j*wc);
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));
[U,S,V] = svd(H1);
Gsvd = inv(U)*G*inv(V');
#+end_src

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{svd}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvd(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{svd}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'northwest');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_svd_low_damping.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_svd_low_damping
#+caption: Diagonal and off-diagonal term when decoupling with SVD on the gravimeter with small damping
#+RESULTS:
[[file:figs/gravimeter_svd_low_damping.png]]

Now take a larger damping, the obtained diagonal and off-diagonal terms are shown in Figure [[fig:gravimeter_svd_high_damping]].
#+begin_src matlab
c = 5e2; % Actuator Damping [N/(m/s)]
#+end_src

#+begin_src matlab :exports none
%% Name of the Simulink File
mdl = 'gravimeter';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F1'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F2'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/F3'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_side'], 2, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 1, 'openoutput'); io_i = io_i + 1;
io(io_i) = linio([mdl, '/Acc_top'], 2, 'openoutput'); io_i = io_i + 1;

G = linearize(mdl, io);
G.InputName  = {'F1', 'F2', 'F3'};
G.OutputName = {'Ax1', 'Ay1', 'Ax2', 'Ay2'};

wc = 2*pi*10; % Decoupling frequency [rad/s]
H1 = evalfr(G, j*wc);
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));
[U,S,V] = svd(H1);
Gsvdd = inv(U)*G*inv(V');
#+end_src

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvdd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvdd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{svd}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvdd(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{svd}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'northwest');
ylim([1e-8, 1e0]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/gravimeter_svd_high_damping.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:gravimeter_svd_high_damping
#+caption: Diagonal and off-diagonal term when decoupling with SVD on the gravimeter with high damping
#+RESULTS:
[[file:figs/gravimeter_svd_high_damping.png]]

* Parallel Manipulator with Collocated actuator/sensor pairs
<<sec:jac_decoupl>>

** Introduction                                                      :ignore:

In this section, we will see how the Jacobian matrix can be used to decouple a specific set of mechanical systems (described in Section [[sec:jac_decoupl_model]]).

The basic decoupling architecture is shown in Figure [[fig:gravimeter_model_analytical]] where the Jacobian matrix is used to both compute the actuator forces from forces/torques that are to be applied in a specific defined frame, and to compute the displacement/rotation of the same mass from several sensors.

This is rapidly explained in Section [[sec:jac_decoupl_jacobian]].

#+begin_src latex :file block_diagram_jacobian_decoupling.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\{M\}}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{\{M\}}^{-1}$};

  % Connections and labels
  \draw[<-] (Jt.west) -- ++(-1.8, 0) node[above right]{$\bm{\mathcal{F}}_{\{M\}}$};
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{\mathcal{L}}$};
  \draw[->] (Ja.east) -- ++( 1.8, 0)  node[above left]{$\bm{\mathcal{X}}_{\{M\}}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=16pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_{\{M\}}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:figs/block_diagram_jacobian_decoupling.png]]

Depending on the chosen frame, the Stiffness matrix in that particular frame can be computed.
This is explained in Section [[sec:jac_decoupl_stiffness]].

Then three decoupling in three specific frames is studied:
- Section [[sec:jac_decoupl_legs]]: control in the frame of the legs
- Section [[sec:jac_decoupl_com]]: control in a frame whose origin is at the center of mass of the payload
- Section [[sec:jac_decoupl_cok]]: control in a frame whose origin is located at the "center of stiffness" of the system

Conclusions are drawn in Section [[sec:jac_decoupl_conclusion]].

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

** Model
<<sec:jac_decoupl_model>>

Let's consider a parallel manipulator with several collocated actuator/sensors pairs.

System in Figure [[fig:gravimeter_model_analytical]] will serve as an example.

We will note:
- $b_i$: location of the joints on the top platform
- $\hat{s}_i$: unit vector corresponding to the struts direction
- $k_i$: stiffness of the struts
- $\tau_i$: actuator forces
- $O_M$: center of mass of the solid body
- $\mathcal{L}_i$: relative displacement of the struts

#+name: fig:gravimeter_model_analytical
#+caption: Model of the gravimeter
[[file:figs/gravimeter_model_analytical.png]]

The parameters are defined as follows:
#+begin_src matlab
l  = 1.0; % Length of the mass [m]
h  = 2*1.7; % Height of the mass [m]

la = l/2; % Position of Act. [m]
ha = h/2; % Position of Act. [m]

m = 400; % Mass [kg]
I = 115; % Inertia [kg m^2]

c1 = 2e1; % Actuator Damping [N/(m/s)]
c2 = 2e1; % Actuator Damping [N/(m/s)]
c3 = 2e1; % Actuator Damping [N/(m/s)]

k1 = 15e3; % Actuator Stiffness [N/m]
k2 = 15e3; % Actuator Stiffness [N/m]
k3 = 15e3; % Actuator Stiffness [N/m]
#+end_src

Let's express ${}^Mb_i$ and $\hat{s}_i$:
\begin{align}
{}^Mb_1 &= [-l/2,\ -h_a] \\
{}^Mb_2 &= [-la, \ -h/2] \\
{}^Mb_3 &= [ la, \ -h/2]
\end{align}

\begin{align}
\hat{s}_1 &= [1,\ 0] \\
\hat{s}_2 &= [0,\ 1] \\
\hat{s}_3 &= [0,\ 1]
\end{align}

#+begin_src matlab
s1 = [1;0];
s2 = [0;1];
s3 = [0;1];

Mb1 = [-l/2;-ha];
Mb2 = [-la; -h/2];
Mb3 = [ la; -h/2];
#+end_src

Frame $\{K\}$ is chosen such that the stiffness matrix is diagonal (explained in Section [[sec:diagonal_stiffness_planar]]).

The positions ${}^Kb_i$ are then:
\begin{align}
{}^Kb_1 &= [-l/2,\ 0] \\
{}^Kb_2 &= [-la, \ -h/2+h_a] \\
{}^Kb_3 &= [ la, \ -h/2+h_a]
\end{align}

#+begin_src matlab
Kb1 = [-l/2; 0];
Kb2 = [-la; -h/2+ha];
Kb3 = [ la; -h/2+ha];
#+end_src

** The Jacobian Matrix
<<sec:jac_decoupl_jacobian>>

Let's note:
- $\bm{\mathcal{L}}$ the vector of actuator displacement:
  \begin{equation}
    \bm{\mathcal{L}} = \begin{bmatrix} \mathcal{L}_1 \\ \mathcal{L}_2 \\ \mathcal{L}_3 \end{bmatrix}
  \end{equation}
- $\bm{\tau}$ the vector of actuator forces:
  \begin{equation}
    \bm{\tau} = \begin{bmatrix} \tau_1 \\ \tau_2 \\ \tau_3 \end{bmatrix}
  \end{equation}
- $\bm{\mathcal{F}}_{\{O\}}$ the vector of forces/torques applied on the payload on expressed in frame $\{O\}$:
  \begin{equation}
    \bm{\mathcal{F}}_{\{O\}} = \begin{bmatrix} \mathcal{F}_{\{O\},x} \\ \mathcal{F}_{\{O\},y} \\ \mathcal{M}_{\{O\},z} \end{bmatrix}
  \end{equation}
- $\bm{\mathcal{X}}_{\{O\}}$ the vector of displacement of the payload with respect to frame $\{O\}$:
  \begin{equation}
    \bm{\mathcal{X}}_{\{O\}} = \begin{bmatrix} \mathcal{X}_{\{O\},x} \\ \mathcal{X}_{\{O\},y} \\ \mathcal{X}_{\{O\},R_z} \end{bmatrix}
  \end{equation}



The Jacobian matrix can be used to:
- Convert joints velocity $\dot{\mathcal{L}}$ to payload velocity and angular velocity $\dot{\bm{\mathcal{X}}}_{\{O\}}$:
  \[ \dot{\bm{\mathcal{X}}}_{\{O\}} = J_{\{O\}} \dot{\bm{\mathcal{L}}} \]
- Convert actuators forces $\bm{\tau}$ to forces/torque applied on the payload $\bm{\mathcal{F}}_{\{O\}}$:
  \[ \bm{\mathcal{F}}_{\{O\}} = J_{\{O\}}^T \bm{\tau} \]
with $\{O\}$ any chosen frame.

If we consider *small* displacements, we have an approximate relation that links the displacements (instead of velocities):
\begin{equation}
\bm{\mathcal{X}}_{\{M\}} = J_{\{M\}} \bm{\mathcal{L}}
\end{equation}


The Jacobian can be computed as follows:
\begin{equation}
J_{\{O\}} = \begin{bmatrix}
  {}^O\hat{s}_1^T & {}^Ob_{1,x} {}^O\hat{s}_{1,y} - {}^Ob_{1,x} {}^O\hat{s}_{1,y} \\
  {}^O\hat{s}_2^T & {}^Ob_{2,x} {}^O\hat{s}_{2,y} - {}^Ob_{2,x} {}^O\hat{s}_{2,y} \\
  \vdots          & \vdots                            \\
  {}^O\hat{s}_n^T & {}^Ob_{n,x} {}^O\hat{s}_{n,y} - {}^Ob_{n,x} {}^O\hat{s}_{n,y} \\
\end{bmatrix}
\end{equation}


Let's compute the Jacobian matrix in frame $\{M\}$ and $\{K\}$:
#+begin_src matlab
Jm = [s1', Mb1(1)*s1(2)-Mb1(2)*s1(1);
      s2', Mb2(1)*s2(2)-Mb2(2)*s2(1);
      s3', Mb3(1)*s3(2)-Mb3(2)*s3(1)];
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Jm
#+end_src

#+caption: Jacobian Matrix $J_{\{M\}}$
#+RESULTS:
| 1 | 0 |  1.7 |
| 0 | 1 | -0.5 |
| 0 | 1 |  0.5 |

#+begin_src matlab
Jk = [s1', Kb1(1)*s1(2)-Kb1(2)*s1(1);
      s2', Kb2(1)*s2(2)-Kb2(2)*s2(1);
      s3', Kb3(1)*s3(2)-Kb3(2)*s3(1)];
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Jk
#+end_src

#+caption: Jacobian Matrix $J_{\{K\}}$
#+RESULTS:
| 1 | 0 |    0 |
| 0 | 1 | -0.5 |
| 0 | 1 |  0.5 |

In the frame $\{M\}$, the Jacobian is:
\begin{equation}
J_{\{M\}} = \begin{bmatrix} 1 & 0 & h_a \\ 0 & 1 & -l_a \\ 0 & 1 & l_a \end{bmatrix}
\end{equation}

And in frame $\{K\}$, the Jacobian is:
\begin{equation}
J_{\{K\}} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & -l_a \\ 0 & 1 & l_a \end{bmatrix}
\end{equation}

** The Stiffness Matrix
<<sec:jac_decoupl_stiffness>>

For a parallel manipulator, the stiffness matrix expressed in a frame $\{O\}$ is:
\begin{equation}
  K_{\{O\}} = J_{\{O\}}^T \mathcal{K} J_{\{O\}}
\end{equation}
where:
- $J_{\{O\}}$ is the Jacobian matrix expressed in frame $\{O\}$
- $\mathcal{K}$ is a diagonal matrix with the strut stiffnesses on the diagonal
  \begin{equation}
  \mathcal{K} = \begin{bmatrix}
    k_1 &     &        & 0 \\
        & k_2 &        &   \\
        &     & \ddots &   \\
    0   &     &        & k_n
  \end{bmatrix}
  \end{equation}

We have the same thing for the damping matrix.

#+begin_src matlab
Kr = diag([k1,k2,k3]);
Cr = diag([c1,c2,c3]);
#+end_src

** Equations of motion - Frame of the legs
<<sec:jac_decoupl_legs>>

Applying the second Newton's law on the system in Figure [[fig:gravimeter_model_analytical]] at its center of mass $O_M$, we obtain:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) \bm{\mathcal{X}}_{\{M\}} = \bm{\mathcal{F}}_{\{M\}}
\end{equation}
with:
- $M_{\{M\}}$ is the mass matrix expressed in $\{M\}$:
  \[ M_{\{M\}} = \begin{bmatrix}m & 0 & 0 \\ 0 & m & 0 \\ 0 & 0 & I\end{bmatrix} \]
- $K_{\{M\}}$ is the stiffness matrix expressed in $\{M\}$:
  \[ K_{\{M\}} = J_{\{M\}}^T \mathcal{K} J_{\{M\}} \]
- $\bm{\mathcal{X}}_{\{M\}}$ are displacements/rotations of the mass $x$, $y$, $R_z$ expressed in the frame $\{M\}$
- $\bm{\mathcal{F}}_{\{M\}}$ are forces/torques $\mathcal{F}_x$, $\mathcal{F}_y$, $\mathcal{M}_z$ applied at the origin of $\{M\}$

Let's use the Jacobian matrix to compute the equations in terms of actuator forces $\bm{\tau}$ and strut displacement $\bm{\mathcal{L}}$:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) J_{\{M\}}^{-1} \bm{\mathcal{L}} = J_{\{M\}}^T \bm{\tau}
\end{equation}

And we obtain:
\begin{equation}
\left( J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} s^2 + \mathcal{K} \right) \bm{\mathcal{L}} = \bm{\tau}
\end{equation}

The transfer function $\bm{G}(s)$ from $\bm{\tau}$ to $\bm{\mathcal{L}}$ is:
\begin{equation}
\boxed{\bm{G}(s) = {\left( J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} s^2 + \mathcal{K} \right)}^{-1}}
\end{equation}

#+begin_src latex :file gravimeter_block_decentralized.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};

  % Connections and labels
  \draw[<-] (G.west) -- ++(-0.8, 0) node[above right]{$\bm{\tau}$};;
  \draw[->] (G.east) -- ++( 0.8, 0)  node[above left]{$\bm{\mathcal{L}}$};
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_block_decentralized
#+caption: Block diagram of the transfer function from $\bm{\tau}$ to $\bm{\mathcal{L}}$
#+RESULTS:
[[file:figs/gravimeter_block_decentralized.png]]

#+begin_src matlab
%% Mass Matrix in frame {M}
Mm = diag([m,m,I]);
#+end_src

Let's note the mass matrix in the frame of the legs:
\begin{equation}
M_{\{L\}} = J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1}
\end{equation}

#+begin_src matlab
%% Mass Matrix in the frame of the struts
Ml = inv(Jm')*Mm*inv(Jm);
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Ml
#+end_src

#+caption: $M_{\{L\}}$
#+RESULTS:
|  400 |   680 |  -680 |
|  680 |  1371 | -1171 |
| -680 | -1171 |  1371 |

As we can see, the Stiffness matrix in the frame of the legs is diagonal.
This means the plant dynamics will be diagonal at low frequency.
#+begin_src matlab
Kl = diag([k1, k2, k3]);
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Kl
#+end_src

#+caption: $K_{\{L\}} = \mathcal{K}$
#+RESULTS:
| 15000 |     0 |     0 |
|     0 | 15000 |     0 |
|     0 |     0 | 15000 |

#+begin_src matlab
Cl = diag([c1, c2, c3]);
#+end_src

The transfer function $\bm{G}(s)$ from $\bm{\tau}$ to $\bm{\mathcal{L}}$ is defined below and its magnitude is shown in Figure [[fig:plant_frame_L]].
#+begin_src matlab
Gl = inv(Ml*s^2 + Cl*s + Kl);
#+end_src

We can indeed see that the system is well decoupled at low frequency.

#+begin_src matlab :exports none
freqs = logspace(-2, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gl(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gl(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$\mathcal{L}_i/\tau_j\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gl(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', ['$\mathcal{L}_', int2str(i_in_out), '/\tau_', int2str(i_in_out), '$']);
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'northeast', 'FontSize', 8);
ylim([1e-8, 1e-2]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/plant_frame_L.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:plant_frame_L
#+caption: Dynamics from $\bm{\tau}$ to $\bm{\mathcal{L}}$
#+RESULTS:
[[file:figs/plant_frame_L.png]]

** Equations of motion - "Center of mass" {M}
<<sec:jac_decoupl_com>>

The equations of motion expressed in frame $\{M\}$ are:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) \bm{\mathcal{X}}_{\{M\}} = \bm{\mathcal{F}}_{\{M\}}
\end{equation}

And the plant from $\bm{F}_{\{M\}}$ to $\bm{\mathcal{X}}_{\{M\}}$ is:
\begin{equation}
\boxed{\bm{G}_{\{X\}} = {\left( M_{\{M\}} s^2 + K_{\{M\}} \right)}^{-1}}
\end{equation}
with:
- $M_{\{M\}}$ is the mass matrix expressed in $\{M\}$:
  \[ M_{\{M\}} = \begin{bmatrix}m & 0 & 0 \\ 0 & m & 0 \\ 0 & 0 & I\end{bmatrix} \]
- $K_{\{M\}}$ is the stiffness matrix expressed in $\{M\}$:
  \[ K_{\{M\}} = J_{\{M\}}^T \mathcal{K} J_{\{M\}} \]

#+begin_src latex :file gravimeter_block_com.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\{M\}}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{\{M\}}^{-1}$};

  % Connections and labels
  \draw[<-] (Jt.west) -- ++(-1.8, 0) node[above right]{$\bm{\mathcal{F}}_{\{M\}}$};
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{\mathcal{L}}$};
  \draw[->] (Ja.east) -- ++( 1.8, 0)  node[above left]{$\bm{\mathcal{X}}_{\{M\}}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=16pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_{\{M\}}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_block_com
#+caption: Block diagram of the transfer function from $\bm{\mathcal{F}}_{\{M\}}$ to $\bm{\mathcal{X}}_{\{M\}}$
#+RESULTS:
[[file:figs/gravimeter_block_com.png]]


#+begin_src matlab
%% Mass Matrix in frame {M}
Mm = diag([m,m,I]);
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Mm
#+end_src

#+caption: Mass matrix expressed in $\{M\}$: $M_{\{M\}}$
#+RESULTS:
| 400 |   0 |   0 |
|   0 | 400 |   0 |
|   0 |   0 | 115 |

#+begin_src matlab
%% Stiffness Matrix in frame {M}
Km = Jm'*Kr*Jm;
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Km
#+end_src

#+caption: Stiffness matrix expressed in $\{M\}$: $K_{\{M\}}$
#+RESULTS:
| 15000 |     0 | 25500 |
|     0 | 30000 |     0 |
| 25500 |     0 | 50850 |

#+begin_src matlab
%% Damping Matrix in frame {M}
Cm = Jm'*Cr*Jm;
#+end_src

The plant from $\bm{F}_{\{M\}}$ to $\bm{\mathcal{X}}_{\{M\}}$ is defined below and its magnitude is shown in Figure [[fig:plant_frame_M]].
#+begin_src matlab
%% Plant in frame {M}
Gm = inv(Mm*s^2 + Cm*s + Km);
#+end_src

#+begin_src matlab :exports none
freqs = logspace(-2, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gm(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gm(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{\\\{M\\\}}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gm(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', ['$G_{\\\{M\\\}}(', int2str(i_in_out), ',', int2str(i_in_out), ')$']);
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southwest', 'FontSize', 8);
ylim([1e-8, 1e-2]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/plant_frame_M.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:plant_frame_M
#+caption: Dynamics from $\bm{\mathcal{F}}_{\{M\}}$ to $\bm{\mathcal{X}}_{\{M\}}$
#+RESULTS:
[[file:figs/plant_frame_M.png]]

** Equations of motion - "Center of stiffness" {K}
<<sec:jac_decoupl_cok>>

Let's now express the transfer function from $\bm{\mathcal{F}}_{\{K\}}$ to $\bm{\mathcal{X}}_{\{K\}}$.
We start from:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) J_{\{M\}}^{-1} \bm{\mathcal{L}} = J_{\{M\}}^T \bm{\tau}
\end{equation}

And we make use of the Jacobian $J_{\{K\}}$ to obtain:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) J_{\{M\}}^{-1} J_{\{K\}} \bm{\mathcal{X}}_{\{K\}} = J_{\{M\}}^T J_{\{K\}}^{-T} \bm{\mathcal{F}}_{\{K\}}
\end{equation}

And finally:
\begin{equation}
\left( J_{\{K\}}^T J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} J_{\{K\}} s^2 + J_{\{K\}}^T \mathcal{K} J_{\{K\}} \right) \bm{\mathcal{X}}_{\{K\}} = \bm{\mathcal{F}}_{\{K\}}
\end{equation}

The transfer function from $\bm{\mathcal{F}}_{\{K\}}$ to $\bm{\mathcal{X}}_{\{K\}}$ is then:
\begin{equation}
\boxed{\bm{G}_{\{K\}} = {\left( J_{\{K\}}^T J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} J_{\{K\}} s^2 + J_{\{K\}}^T \mathcal{K} J_{\{K\}} \right)}^{-1}}
\end{equation}

The frame $\{K\}$ has been chosen such that $J_{\{K\}}^T \mathcal{K} J_{\{K\}}$ is diagonal.

#+begin_src latex :file gravimeter_block_cok.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\{K\}}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{\{K\}}^{-1}$};

  % Connections and labels
  \draw[<-] (Jt.west) -- ++(-1.8, 0) node[above right]{$\bm{\mathcal{F}}_{\{K\}}$};
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{\mathcal{L}}$};
  \draw[->] (Ja.east) -- ++( 1.8, 0)  node[above left]{$\bm{\mathcal{X}}_{\{K\}}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=16pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_{\{K\}}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:gravimeter_block_cok
#+caption: Block diagram of the transfer function from $\bm{\mathcal{F}}_{\{K\}}$ to $\bm{\mathcal{X}}_{\{K\}}$
#+RESULTS:
[[file:figs/gravimeter_block_cok.png]]

#+begin_src matlab
Mk = Jk'*inv(Jm)'*Mm*inv(Jm)*Jk;
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Mk
#+end_src

#+caption: Mass matrix expressed in $\{K\}$: $M_{\{K\}}$
#+RESULTS:
|  400 |   0 | -680 |
|    0 | 400 |    0 |
| -680 |   0 | 1271 |

#+begin_src matlab
Kk = Jk'*Kr*Jk;
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Kk
#+end_src

#+caption: Stiffness matrix expressed in $\{K\}$: $K_{\{K\}}$
#+RESULTS:
| 15000 |     0 |    0 |
|     0 | 30000 |    0 |
|     0 |     0 | 7500 |

The plant from $\bm{F}_{\{K\}}$ to $\bm{\mathcal{X}}_{\{K\}}$ is defined below and its magnitude is shown in Figure [[fig:plant_frame_K]].
#+begin_src matlab
Gk = inv(Mk*s^2 + Ck*s + Kk);
#+end_src

#+begin_src matlab :exports none
freqs = logspace(-2, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [1:i_in-1, i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gk(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gk(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{\\\{K\\\}}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gk(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', ['$G_{\\\{K\\\}}(', int2str(i_in_out), ',', int2str(i_in_out), ')$']);
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
legend('location', 'southwest', 'FontSize', 8);
ylim([1e-8, 1e-2]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/plant_frame_K.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:plant_frame_K
#+caption: Dynamics from $\bm{\mathcal{F}}_{\{K\}}$ to $\bm{\mathcal{X}}_{\{K\}}$
#+RESULTS:
[[file:figs/plant_frame_K.png]]

** Conclusion
<<sec:jac_decoupl_conclusion>>

* SVD / Jacobian / Model decoupling comparison
** Introduction                                                      :ignore:

The goal of this section is to compare the use of several methods for the decoupling of parallel manipulators.

It is structured as follow:
- Section [[sec:decoupling_comp_model]]: the model used to compare/test decoupling strategies is presented
- Section [[sec:comp_jacobian]]: decoupling using Jacobian matrices is presented
- Section [[sec:comp_modal]]: modal decoupling is presented
- Section [[sec:comp_svd]]: SVD decoupling is presented
- Section [[sec:decoupling_comp]]: the three decoupling methods are applied on the test model and compared
- Section [[sec:decoupling_conclusion]]: conclusions are drawn on the three decoupling methods

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

#+begin_src matlab :tangle no
addpath('matlab')
#+end_src

#+begin_src matlab
freqs = logspace(-1, 2, 1000);
#+end_src

** Test Model
<<sec:decoupling_comp_model>>
Let's consider a parallel manipulator with several collocated actuator/sensors pairs.

System in Figure [[fig:model_test_decoupling]] will serve as an example.

We will note:
- $b_i$: location of the joints on the top platform
- $\hat{s}_i$: unit vector corresponding to the struts direction
- $k_i$: stiffness of the struts
- $\tau_i$: actuator forces
- $O_M$: center of mass of the solid body
- $\mathcal{L}_i$: relative displacement of the struts

#+name: fig:model_test_decoupling
#+caption: Model use to compare decoupling techniques
[[file:figs/model_test_decoupling.png]]

The parameters are defined below.

#+begin_src matlab
%% System parameters
l  = 1.0; % Length of the mass [m]
h  = 2*1.7; % Height of the mass [m]

la = l/2; % Position of Act. [m]
ha = h/2; % Position of Act. [m]

m = 400; % Mass [kg]
I = 115; % Inertia [kg m^2]

%% Actuator Damping [N/(m/s)]
c1 = 2e1;
c2 = 2e1;
c3 = 2e1;

%% Actuator Stiffness [N/m]
k1 = 15e3;
k2 = 15e3;
k3 = 15e3;

%% Unit vectors of the actuators
s1 = [1;0];
s2 = [0;1];
s3 = [0;1];

%%  Location of the joints
Mb1 = [-l/2;-ha];
Mb2 = [-la; -h/2];
Mb3 = [ la; -h/2];

%% Jacobian matrix
J = [s1', Mb1(1)*s1(2)-Mb1(2)*s1(1);
     s2', Mb2(1)*s2(2)-Mb2(2)*s2(1);
     s3', Mb3(1)*s3(2)-Mb3(2)*s3(1)];

%% Stiffnesss and Damping matrices of the struts
Kr = diag([k1,k2,k3]);
Cr = diag([c1,c2,c3]);
#+end_src

#+begin_src matlab
%% Mass Matrix in frame {M}
M = diag([m,m,I]);

%% Stiffness Matrix in frame {M}
K = J'*Kr*J;

%% Damping Matrix in frame {M}
C = J'*Cr*J;
#+end_src

The plant from $\bm{\tau}$ to $\bm{\mathcal{L}}$ is defined below
#+begin_src matlab
%% Plant in frame {M}
G = J*inv(M*s^2 + C*s + K)*J';
#+end_src

The magnitude of the coupled plant $G$ is shown in Figure [[fig:coupled_plant_bode]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 3, 'TileSpacing', 'None', 'Padding', 'None');

for out_i = 1:3
    for in_i = 1:3
        nexttile;
        plot(freqs, abs(squeeze(freqresp(G(out_i,in_i), freqs, 'Hz'))), 'k-', ...
             'DisplayName', sprintf('$\\mathcal{L}_%i/\\tau_%i$', out_i, in_i));
        set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
        xlim([1e-1, 2e1]); ylim([1e-6, 1e-2]);
        legend('location', 'northeast', 'FontSize', 8);

        if in_i == 1
            ylabel('Mag. [m/N]')
        else
            set(gca, 'YTickLabel',[]);
        end

        if out_i == 3
            xlabel('Frequency [Hz]')
        else
            set(gca, 'XTickLabel',[]);
        end
    end
end
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/coupled_plant_bode.pdf', 'width', 'full', 'height', 'tall');
#+end_src

#+name: fig:coupled_plant_bode
#+caption: Magnitude of the coupled plant.
#+RESULTS:
[[file:figs/coupled_plant_bode.png]]


** Jacobian Decoupling
<<sec:comp_jacobian>>

The Jacobian matrix can be used to:
- Convert joints velocity $\dot{\mathcal{L}}$ to payload velocity and angular velocity $\dot{\bm{\mathcal{X}}}_{\{O\}}$:
  \[ \dot{\bm{\mathcal{X}}}_{\{O\}} = J_{\{O\}} \dot{\bm{\mathcal{L}}} \]
- Convert actuators forces $\bm{\tau}$ to forces/torque applied on the payload $\bm{\mathcal{F}}_{\{O\}}$:
  \[ \bm{\mathcal{F}}_{\{O\}} = J_{\{O\}}^T \bm{\tau} \]
with $\{O\}$ any chosen frame.

By wisely choosing frame $\{O\}$, we can obtain nice decoupling for plant:
\begin{equation}
  \bm{G}_{\{O\}} = J_{\{O\}}^{-1} \bm{G} J_{\{O\}}^{-T}
\end{equation}

The obtained plan corresponds to forces/torques applied on origin of frame $\{O\}$ to the translation/rotation of the payload expressed in frame $\{O\}$.

#+begin_src latex :file jacobian_decoupling_arch.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Jt) {$J_{\{O\}}^{-T}$};
  \node[block, right=0.6 of G] (Ja) {$J_{\{O\}}^{-1}$};

  % Connections and labels
  \draw[<-] (Jt.west) -- ++(-1.8, 0) node[above right]{$\bm{\mathcal{F}}_{\{O\}}$};
  \draw[->] (Jt.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Ja.west)  node[above left]{$\bm{\mathcal{L}}$};
  \draw[->] (Ja.east) -- ++( 1.8, 0)  node[above left]{$\bm{\mathcal{X}}_{\{O\}}$};

  \begin{scope}[on background layer]
    \node[fit={(Jt.south west) (Ja.north east)}, fill=black!10!white, draw, dashed, inner sep=16pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_{\{O\}}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:jacobian_decoupling_arch
#+caption: Block diagram of the transfer function from $\bm{\mathcal{F}}_{\{O\}}$ to $\bm{\mathcal{X}}_{\{O\}}$
#+RESULTS:
[[file:figs/jacobian_decoupling_arch.png]]

#+begin_important
The Jacobian matrix is only based on the geometry of the system and does not depend on the physical properties such as mass and stiffness.

The inputs and outputs of the decoupled plant $\bm{G}_{\{O\}}$ have physical meaning:
- $\bm{\mathcal{F}}_{\{O\}}$ are forces/torques applied on the payload at the origin of frame $\{O\}$
- $\bm{\mathcal{X}}_{\{O\}}$ are translations/rotation of the payload expressed in frame $\{O\}$

It is then easy to include a reference tracking input that specify the wanted motion of the payload in the frame $\{O\}$.
#+end_important

** Modal Decoupling
<<sec:comp_modal>>

Let's consider a system with the following equations of motion:
\begin{equation}
M \bm{\ddot{x}} + C \bm{\dot{x}}  + K \bm{x} = \bm{\mathcal{F}}
\end{equation}

And the measurement output is a combination of the motion variable $\bm{x}$:
\begin{equation}
\bm{y} = C_{ox} \bm{x} + C_{ov} \dot{\bm{x}}
\end{equation}

Let's make a *change of variables*:
\begin{equation}
\boxed{\bm{x} = \Phi \bm{x}_m}
\end{equation}
with:
- $\bm{x}_m$ the modal amplitudes
- $\Phi$ a matrix whose columns are the modes shapes of the system

And we map the actuator forces:
\begin{equation}
\bm{\mathcal{F}} = J^T \bm{\tau}
\end{equation}

The equations of motion become:
\begin{equation}
M \Phi \bm{\ddot{x}}_m + C \Phi \bm{\dot{x}}_m  + K \Phi \bm{x}_m = J^T \bm{\tau}
\end{equation}
And the measured output is:
\begin{equation}
\bm{y} = C_{ox} \Phi \bm{x}_m + C_{ov} \Phi \dot{\bm{x}}_m
\end{equation}

By pre-multiplying the EoM by $\Phi^T$:
\begin{equation}
\Phi^T M \Phi \bm{\ddot{x}}_m + \Phi^T C \Phi \bm{\dot{x}}_m  + \Phi^T K \Phi \bm{x}_m = \Phi^T J^T \bm{\tau}
\end{equation}

And we note:
- $M_m = \Phi^T M \Phi = \text{diag}(\mu_i)$ the modal mass matrix
- $C_m = \Phi^T C \Phi = \text{diag}(2 \xi_i \mu_i \omega_i)$ (classical damping)
- $K_m = \Phi^T K \Phi = \text{diag}(\mu_i \omega_i^2)$ the modal stiffness matrix

And we have:
\begin{equation}
  \ddot{\bm{x}}_m + 2 \Xi \Omega \dot{\bm{x}}_m + \Omega^2 \bm{x}_m = \mu^{-1} \Phi^T J^T \bm{\tau}
\end{equation}
with:
- $\mu = \text{diag}(\mu_i)$
- $\Omega = \text{diag}(\omega_i)$
- $\Xi = \text{diag}(\xi_i)$

And we call the *modal input matrix*:
\begin{equation}
  \boxed{B_m = \mu^{-1} \Phi^T J^T}
\end{equation}
And the *modal output matrices*:
\begin{equation}
  \boxed{C_m = C_{ox} \Phi + C_{ov} \Phi s}
\end{equation}


Let's note the "modal input":
\begin{equation}
\bm{\tau}_m = B_m \bm{\tau}
\end{equation}

The transfer function from $\bm{\tau}_m$ to $\bm{x}_m$ is:
\begin{equation} \label{eq:modal_eq}
\boxed{\frac{\bm{x}_m}{\bm{\tau}_m} = \left( I_n s^2 + 2 \Xi \Omega s + \Omega^2 \right)^{-1}}
\end{equation}
which is a *diagonal* transfer function matrix.
We therefore have decoupling of the dynamics from $\bm{\tau}_m$ to $\bm{x}_m$.


We now expressed the transfer function from input $\bm{\tau}$ to output $\bm{y}$ as a function of the "modal variables":
\begin{equation}
  \boxed{\frac{\bm{y}}{\bm{\tau}} = \underbrace{\left( C_{ox} + s C_{ov} \right) \Phi}_{C_m} \underbrace{\left( I_n s^2 + 2 \Xi \Omega s + \Omega^2 \right)^{-1}}_{\text{diagonal}} \underbrace{\left( \mu^{-1} \Phi^T J^T \right)}_{B_m}}
\end{equation}

By inverting $B_m$ and $C_m$ and using them as shown in Figure [[fig:modal_decoupling_architecture]], we can see that we control the system in the "modal space" in which it is decoupled.

#+begin_src latex :file decoupling_modal.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};
  \node[block, left=0.6 of G] (Bm) {$B_m^{-1}$};
  \node[block, right=0.6 of G] (Cm) {$C_m^{-1}$};

  % Connections and labels
  \draw[<-] (Bm.west) -- ++(-1.4, 0) node[above right]{$\bm{\tau}_m$};
  \draw[->] (Bm.east) -- (G.west)  node[above left]{$\bm{\tau}$};
  \draw[->] (G.east) -- (Cm.west)  node[above left]{$\bm{y}$};
  \draw[->] (Cm.east) -- ++( 1.4, 0)  node[above left]{$\bm{x}_m$};

  \begin{scope}[on background layer]
    \node[fit={(Bm.south west) (Cm.north east)}, fill=black!10!white, draw, dashed, inner sep=16pt] (Gm) {};
    \node[below right] at (Gm.north west) {$\bm{G}_m$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:modal_decoupling_architecture
#+caption: Modal Decoupling Architecture
#+RESULTS:
[[file:figs/decoupling_modal.png]]

The system $\bm{G}_m(s)$ shown in Figure [[fig:modal_decoupling_architecture]] is diagonal eqref:eq:modal_eq.

#+begin_important
Modal decoupling requires to have the equations of motion of the system.
From the equations of motion (and more precisely the mass and stiffness matrices), the mode shapes $\Phi$ are computed.

Then, the system can be decoupled in the modal space.
The obtained system on the diagonal are second order resonant systems which can be easily controlled.

Using this decoupling strategy, it is possible to control each mode individually.
#+end_important

** SVD Decoupling
<<sec:comp_svd>>

Procedure:
- Identify the dynamics of the system from inputs to outputs (can be obtained experimentally)
- Choose a frequency where we want to decouple the system (usually, the crossover frequency is a good choice)
#+begin_src matlab :eval no
%% Decoupling frequency [rad/s]
wc = 2*pi*10;

%% System's response at the decoupling frequency
H1 = evalfr(G, j*wc);
#+end_src
- Compute a real approximation of the system's response at that frequency
#+begin_src matlab :eval no
%% Real approximation of G(j.wc)
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));
#+end_src
- Perform a Singular Value Decomposition of the real approximation
#+begin_src matlab :eval no
[U,S,V] = svd(H1);
#+end_src
- Use the singular input and output matrices to decouple the system as shown in Figure [[fig:decoupling_svd]]
  \[ G_{svd}(s) = U^{-1} G(s) V^{-T} \]
#+begin_src matlab :eval no
Gsvd = inv(U)*G*inv(V');
#+end_src

#+begin_src latex :file decoupling_svd.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$\bm{G}$};

  \node[block, left=0.6 of G.west] (V) {$V^{-T}$};
  \node[block, right=0.6 of G.east] (U) {$U^{-1}$};

  % Connections and labels
  \draw[<-] (V.west) -- ++(-1.0, 0) node[above right]{$u$};
  \draw[->] (V.east) -- (G.west) node[above left]{$\tau$};
  \draw[->] (G.east) -- (U.west) node[above left]{$a$};
  \draw[->] (U.east) -- ++( 1.0, 0) node[above left]{$y$};

  \begin{scope}[on background layer]
    \node[fit={(V.south west) (G.north-|U.east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gsvd) {};
    \node[below right] at (Gsvd.north west) {$\bm{G}_{SVD}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:decoupling_svd
#+caption: Decoupled plant $\bm{G}_{SVD}$ using the Singular Value Decomposition
#+RESULTS:
[[file:figs/decoupling_svd.png]]

#+begin_important
In order to apply the Singular Value Decomposition, we need to have the Frequency Response Function of the system, at least near the frequency where we wish to decouple the system.
The FRF can be experimentally obtained or based from a model.

This method ensure good decoupling near the chosen frequency, but no guaranteed decoupling away from this frequency.

Also, it depends on how good the real approximation of the FRF is, therefore it might be less good for plants with high damping.

This method is quite general and can be applied to any type of system.
The inputs and outputs are ordered from higher gain to lower gain at the chosen frequency.

- [ ] Do we loose any physical meaning of the obtained inputs and outputs?
- [ ] Can we take advantage of the fact that U and V are unitary?
#+end_important

** Comparison
<<sec:decoupling_comp>>
*** Jacobian Decoupling
Decoupling properties depends on the chosen frame $\{O\}$.

Let's take the CoM as the decoupling frame.

#+begin_src matlab
Gx = pinv(J)*G*pinv(J');
Gx.InputName  = {'Fx', 'Fy', 'Mz'};
Gx.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gx(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gx(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{x}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gx(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{x}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-7, 1e-1]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/jacobian_plant.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:jacobian_plant
#+caption: Plant decoupled using the Jacobian matrices $G_x(s)$
#+RESULTS:
[[file:figs/jacobian_plant.png]]

*** Modal Decoupling
For the system in Figure [[fig:model_test_decoupling]], we have:
\begin{align}
\bm{x} &= \begin{bmatrix} x \\ y \\ R_z \end{bmatrix} \\
\bm{y} &= \mathcal{L} = J \bm{x}; \quad C_{ox} = J; \quad C_{ov} = 0 \\
M &= \begin{bmatrix}
m & 0 & 0 \\
0 & m & 0 \\
0 & 0 & I
\end{bmatrix}; \quad K = J' \begin{bmatrix}
k & 0 & 0 \\
0 & k & 0 \\
0 & 0 & k
\end{bmatrix} J; \quad C = J' \begin{bmatrix}
c & 0 & 0 \\
0 & c & 0 \\
0 & 0 & c
\end{bmatrix} J
\end{align}

In order to apply the architecture shown in Figure [[fig:modal_decoupling_architecture]], we need to compute $C_{ox}$, $C_{ov}$, $\Phi$, $\mu$ and $J$.

#+begin_src matlab
%% Modal Decomposition
[V,D] = eig(M\K);

%% Modal Mass Matrix
mu = V'*M*V;

%% Modal output matrix
Cm = J*V;

%% Modal input matrix
Bm = inv(mu)*V'*J';
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(Bm, {}, {}, ' %.4f ');
#+end_src

#+name: tab:modal_decoupling_Bm
#+caption: $B_m$ matrix
#+attr_latex: :environment tabularx :width 0.3\linewidth :align ccc
#+attr_latex: :center t :booktabs t :float t
#+RESULTS:
| -0.0004 | -0.0007 |  0.0007 |
| -0.0151 |  0.0041 | -0.0041 |
|     0.0 |  0.0025 |  0.0025 |

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(Cm, {}, {}, ' %.1f ');
#+end_src

#+name: tab:modal_decoupling_Cm
#+caption: $C_m$ matrix
#+attr_latex: :environment tabularx :width 0.2\linewidth :align ccc
#+attr_latex: :center t :booktabs t :float t
#+RESULTS:
| -0.1 | -1.8 | 0.0 |
| -0.2 |  0.5 | 1.0 |
|  0.2 | -0.5 | 1.0 |

And the plant in the modal space is defined below and its magnitude is shown in Figure [[fig:modal_plant]].
#+begin_src matlab
Gm = inv(Cm)*G*inv(Bm);
#+end_src

#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gm(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gm(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_m(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gm(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_m(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-6, 1e2]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/modal_plant.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:modal_plant
#+caption: Modal plant $G_m(s)$
#+RESULTS:
[[file:figs/modal_plant.png]]

Let's now close one loop at a time and see how the transmissibility changes.

*** SVD Decoupling
#+begin_src matlab
%% Decoupling frequency [rad/s]
wc = 2*pi*10;

%% System's response at the decoupling frequency
H1 = evalfr(G, j*wc);

%% Real approximation of G(j.wc)
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));

[U,S,V] = svd(H1);

Gsvd = inv(U)*G*inv(V');
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(H1, {}, {}, ' %.2g ');
#+end_src

#+caption: Real approximate of $G$ at the decoupling frequency $\omega_c$
#+attr_latex: :environment tabularx :width 0.3\linewidth :align ccc
#+attr_latex: :center t :booktabs t :float t
#+RESULTS:
|   -8e-06 |  2.1e-06 | -2.1e-06 |
|  2.1e-06 | -1.3e-06 | -2.5e-08 |
| -2.1e-06 | -2.5e-08 | -1.3e-06 |

- [ ] Do we have something special when applying SVD to a collocated MIMO system?
- When applying SVD on a non-collocated MIMO system, we obtained a decoupled plant looking like the one in Figure [[fig:gravimeter_svd_plant]]

#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvd(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{svd}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvd(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{svd}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
% ylim([1e-8, 1e-2]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/svd_plant.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:svd_plant
#+caption: Svd plant $G_m(s)$
#+RESULTS:
[[file:figs/svd_plant.png]]

** Robustness of the decoupling strategies?
*** Introduction                                                    :ignore:
What happens if we add an additional resonance in the system (Figure [[fig:model_test_decoupling_spurious_res]]).

Having less actuator than DoF (under-actuated system):
- modal decoupling: can still control first $n$ modes?
- SVD decoupling: does not matter
- Jacobian decoupling: could give poor decoupling?

#+name: fig:model_test_decoupling_spurious_res
#+caption: Plant with spurious resonance (additional DoF)
[[file:figs/model_test_decoupling_spurious_res.png]]

*** Plant
A multi body model of the system in Figure [[fig:model_test_decoupling_spurious_res]] has been made using Simscape.

Its parameters are defined below:
#+begin_src matlab
leq = 20e-3; % Equilibrium length of struts [m]
mr = 5; % [kg]
kr = (2*pi*10)^2*mr; % Stiffness [N/m]
cr = 1e1; % Damping [N/(m/s)]

m = 400 - mr; % Mass [kg]
#+end_src

The plant is then identified and shown in Figure [[fig:coupled_plant_bode_spurious]].
The added resonance only slightly modifies the plant around 10Hz.
#+begin_src matlab :exports none
%% Name of the Simulink File
mdl = 'suspended_mass';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/F'],  1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/dL'], 1, 'openoutput'); io_i = io_i + 1;

Gr = linearize(mdl, io);
Gr.InputName  = {'F1', 'F2', 'F3'};
Gr.OutputName = {'L1', 'L2', 'L3'};
#+end_src

#+begin_src matlab :exports none
figure;
tiledlayout(3, 3, 'TileSpacing', 'None', 'Padding', 'None');

for out_i = 1:3
    for in_i = 1:3
        nexttile;
        hold on;
        plot(freqs, abs(squeeze(freqresp(G(out_i,in_i), freqs, 'Hz'))), 'k-', ...
             'DisplayName', sprintf('$\\mathcal{L}_%i/\\tau_%i$', out_i, in_i));
        plot(freqs, abs(squeeze(freqresp(Gr(out_i,in_i), freqs, 'Hz'))), 'k--', ...
             'HandleVisibility', 'off');
        hold off;
        set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
        xlim([1e-1, 2e1]); ylim([1e-6, 1e-2]);
        legend('location', 'northeast', 'FontSize', 8);

        if in_i == 1
            ylabel('Mag. [m/N]')
        else
            set(gca, 'YTickLabel',[]);
        end

        if out_i == 3
            xlabel('Frequency [Hz]')
        else
            set(gca, 'XTickLabel',[]);
        end
    end
end
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/coupled_plant_bode_spurious.pdf', 'width', 'full', 'height', 'tall');
#+end_src

#+name: fig:coupled_plant_bode_spurious
#+caption: Magnitude of the coupled plant without additional mode (solid) and with the additional mode (dashed).
#+RESULTS:
[[file:figs/coupled_plant_bode_spurious.png]]

*** Jacobian Decoupling
The obtained plant is decoupled using the Jacobian matrix.

#+begin_src matlab
Gxr = pinv(J)*Gr*pinv(J');
Gxr.InputName  = {'Fx', 'Fy', 'Mz'};
Gxr.OutputName  = {'Dx', 'Dy', 'Rz'};
#+end_src

The obtained plant is shown in Figure [[fig:jacobian_plant_spurious]] and is not much different than for the plant without the spurious resonance.
#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gxr(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gxr(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{x,r}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gxr(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{x,r}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-7, 1e-1]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/jacobian_plant_spurious.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:jacobian_plant_spurious
#+caption: Plant with spurious resonance decoupled using the Jacobian matrices $G_{x,r}(s)$
#+RESULTS:
[[file:figs/jacobian_plant_spurious.png]]

*** Modal Decoupling
The obtained plant is now decoupled using the modal matrices obtained with the plant not including the added resonance.
#+begin_src matlab
Gmr = inv(Cm)*Gr*inv(Bm);
#+end_src

The obtained decoupled plant is shown in Figure [[fig:modal_plant_spurious]].
Compare to the decoupled plant in Figure [[fig:modal_plant]], the added resonance induces some coupling, especially around the frequency of the added spurious resonance.
#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gmr(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gmr(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{m,r}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gmr(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{m,r}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-6, 1e2]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/modal_plant_spurious.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:modal_plant_spurious
#+caption: Modal plant including spurious resonance $G_{m,r}(s)$
#+RESULTS:
[[file:figs/modal_plant_spurious.png]]

*** SVD Decoupling
The SVD decoupling is performed on the new obtained plant.
The decoupling frequency is slightly shifted in order not to interfere too much with the spurious resonance.

#+begin_src matlab
%% Decoupling frequency [rad/s]
wc = 2*pi*7;

%% System's response at the decoupling frequency
H1 = evalfr(Gr, j*wc);

%% Real approximation of G(j.wc)
D = pinv(real(H1'*H1));
H1 = pinv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));

[U,S,V] = svd(H1);

Gsvdr = inv(U)*Gr*inv(V');
#+end_src

The obtained plant is shown in Figure [[fig:svd_plant_spurious]].
#+begin_src matlab :exports none
freqs = logspace(-1, 2, 1000);
figure;

% Magnitude
hold on;
for i_in = 1:3
    for i_out = [i_in+1:3]
        plot(freqs, abs(squeeze(freqresp(Gsvdr(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvdr(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_{svd,r}(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:3
    plot(freqs, abs(squeeze(freqresp(Gsvdr(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_{svd,r}(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-8, 1e-2]);
legend('location', 'northeast');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/svd_plant_spurious.pdf', 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:svd_plant_spurious
#+caption: SVD decoupled plant including a spurious resonance $G_{svd,r}(s)$
#+RESULTS:
[[file:figs/svd_plant_spurious.png]]

** Conclusion
<<sec:decoupling_conclusion>>

The three proposed methods clearly have a lot in common as they all tend to make system more decoupled by pre and/or post multiplying by a constant matrix
However, the three methods also differs by a number of points which are summarized in Table [[tab:decoupling_strategies_comp]].

Other decoupling strategies could be included in this study, such as:
- DC decoupling: pre-multiply the plant by $G(0)^{-1}$
- full decoupling: pre-multiply the plant by $G(s)^{-1}$

#+name: tab:decoupling_strategies_comp
#+caption: Comparison of decoupling strategies
#+attr_latex: :environment tabularx :width \linewidth :align lXXX
#+attr_latex: :center t :booktabs t :float sideways
|                           | *Jacobian*                                                                             | *Modal*                                                            | *SVD*                                                  |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Philosophy*              | Topology Driven                                                                        | Physics Driven                                                     | Data Driven                                            |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Requirements*            | Known geometry                                                                         | Known equations of motion                                          | Identified FRF                                         |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Decoupling Matrices*     | Decoupling using $J$ obtained from geometry                                            | Decoupling using $\Phi$ obtained from modal decomposition          | Decoupling using $U$ and $V$ obtained from SVD         |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Decoupled Plant*         | $\bm{G}_{\{O\}} = J_{\{O\}}^{-1} \bm{G} J_{\{O\}}^{-T}$                                | $\bm{G}_m = C_m^{-1} \bm{G} B_m^{-1}$                              | $\bm{G}_{svd}(s) = U^{-1} \bm{G}(s) V^{-T}$            |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Implemented Controller*  | $\bm{K}_{\{O\}} = J_{\{O\}}^{-T} \bm{K}_{d}(s) J_{\{O\}}^{-1}$                         | $\bm{K}_m = B_m^{-1} \bm{K}_{d}(s) C_m^{-1}$                       | $\bm{K}_{svd}(s) = V^{-T} \bm{K}_{d}(s) U^{-1}$        |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Physical Interpretation* | Forces/Torques to Displacement/Rotation in chosen frame                                | Inputs to excite individual modes                                  | Directions of max to min controllability/observability |
|                           |                                                                                        | Output to sense individual modes                                   |                                                        |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Decoupling Properties*   | Decoupling at low or high frequency depending on the chosen frame                      | Good decoupling at all frequencies                                 | Good decoupling near the chosen frequency              |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Pros*                    | Physical inputs / outputs                                                              | Target specific modes                                              | Good Decoupling near the crossover                     |
|                           | Good decoupling at High frequency (diagonal mass matrix if Jacobian taken at the CoM)  | 2nd order diagonal plant                                           | Very General                                           |
|                           | Good decoupling at Low frequency (if Jacobian taken at specific point)                 |                                                                    |                                                        |
|                           | Easy integration of meaningful reference inputs                                        |                                                                    |                                                        |
|                           |                                                                                        |                                                                    |                                                        |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Cons*                    | Coupling between force/rotation may be high at low frequency (non diagonal terms in K) | Need analytical equations                                          | Loose the physical meaning of inputs /outputs          |
|                           | Limited to parallel mechanisms (?)                                                     |                                                                    | Decoupling depends on the real approximation validity  |
|                           | If good decoupling at all frequencies => requires specific mechanical architecture     |                                                                    | Diagonal plants may not be easy to control             |
|---------------------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------+--------------------------------------------------------|
| *Applicability*           | Parallel Mechanisms                                                                    | Systems whose dynamics that can be expressed with M and K matrices | Very general                                           |
|                           | Only small motion for the Jacobian matrix to stay constant                             |                                                                    | Need FRF data (either experimentally or analytically)  |


* Diagonal Stiffness Matrix for a planar manipulator
<<sec:diagonal_stiffness_planar>>
** Model and Assumptions
Consider a parallel manipulator with:
- $b_i$: location of the joints on the top platform are called $b_i$
- $\hat{s}_i$: unit vector corresponding to the struts
- $k_i$: stiffness of the struts
- $\tau_i$: actuator forces
- $O_M$: center of mass of the solid body

Consider two frames:
- $\{M\}$ with origin $O_M$
- $\{K\}$ with origin $O_K$

As an example, take the system shown in Figure [[fig:3dof_model_fully_parallel]].

#+name: fig:3dof_model_fully_parallel
#+caption: Example of 3DoF parallel platform
[[file:figs/3dof_model_fully_parallel.png]]

** Objective

The objective is to find conditions for the existence of a frame $\{K\}$ in which the Stiffness matrix of the manipulator is diagonal.
If the conditions are fulfilled, a second objective is to fine the location of the frame $\{K\}$ analytically.

** Conditions for Diagonal Stiffness
The stiffness matrix in the frame $\{K\}$ can be expressed as:
\begin{equation} \label{eq:stiffness_formula_planar}
  K_{\{K\}} = J_{\{K\}}^T \mathcal{K} J_{\{K\}}
\end{equation}
where:
- $J_{\{K\}}$ is the Jacobian transformation from the struts to the frame $\{K\}$
- $\mathcal{K}$ is a diagonal matrix with the strut stiffnesses on the diagonal
  \begin{equation}
  \mathcal{K} = \begin{bmatrix}
    k_1 &     &        & 0 \\
        & k_2 &        &   \\
        &     & \ddots &   \\
    0   &     &        & k_n
  \end{bmatrix}
  \end{equation}

The Jacobian for a planar manipulator, evaluated in a frame $\{K\}$, can be expressed as follows:
\begin{equation} \label{eq:jacobian_planar}
J_{\{K\}} = \begin{bmatrix}
  {}^K\hat{s}_1^T & {}^Kb_{1,x} {}^K\hat{s}_{1,y} - {}^Kb_{1,x} {}^K\hat{s}_{1,y} \\
  {}^K\hat{s}_2^T & {}^Kb_{2,x} {}^K\hat{s}_{2,y} - {}^Kb_{2,x} {}^K\hat{s}_{2,y} \\
  \vdots          & \vdots                            \\
  {}^K\hat{s}_n^T & {}^Kb_{n,x} {}^K\hat{s}_{n,y} - {}^Kb_{n,x} {}^K\hat{s}_{n,y} \\
\end{bmatrix}
\end{equation}

Let's omit the mention of frame, it is assumed that vectors are expressed in frame $\{K\}$.
It is specified otherwise.

Injecting eqref:eq:jacobian_planar into eqref:eq:stiffness_formula_planar yields:
\begin{equation}
\boxed{
K_{\{K\}} = \left[ \begin{array}{c|c}
  k_i \hat{s}_i \hat{s}_i^T              & k_i \hat{s}_i (b_{i,x}\hat{s}_{i,y} - b_{i,y}\hat{s}_{i,x}) \cr
  \hline
  k_i \hat{s}_i (b_{i,x}\hat{s}_{i,y} - b_{i,y}\hat{s}_{i,x}) & k_i (b_{i,x}\hat{s}_{i,y} - b_{i,y}\hat{s}_{i,x})^2
\end{array} \right]
}
\end{equation}

In order to have a decoupled stiffness matrix, we have the following two conditions:
\begin{align}
k_i \hat{s}_i \hat{s}_i^T &= \text{diag. matrix} \label{eq:diag_cond_2D_1} \\
k_i \hat{s}_i (b_{i,x}\hat{s}_{i,y} - b_{i,y}\hat{s}_{i,x}) &= 0 \label{eq:diag_cond_2D_2}
\end{align}

Note that we don't have any condition on the term $k_i (b_{i,x}\hat{s}_{i,y} - b_{i,y}\hat{s}_{i,x})^2$ as it is only a scalar.

Condition eqref:eq:diag_cond_2D_1:
- represents the coupling between translations and forces
- does only depends on the orientation of the struts and the stiffnesses and not on the choice of frame
- it is therefore a intrinsic property of the chosen geometry

Condition eqref:eq:diag_cond_2D_2:
- represents the coupling between forces/rotations and torques/translation
- it does depend on the positions of the joints $b_i$ in the frame $\{K\}$

Let's make a change of frame from the initial frame $\{M\}$ to the frame $\{K\}$:
\begin{align}
{}^Kb_i &= {}^Mb_i - {}^MO_K \\
{}^K\hat{s}_i &= {}^M\hat{s}_i
\end{align}

And the goal is to find ${}^MO_K$ such that eqref:eq:diag_cond_2D_2 is fulfilled:
\begin{equation}
k_i ({}^Mb_{i,x}\hat{s}_{i,y} - {}^Mb_{i,y}\hat{s}_{i,x} - {}^MO_{K,x}\hat{s}_{i,y} + {}^MO_{K,y}\hat{s}_{i,x}) \hat{s}_i = 0
\end{equation}
\begin{equation}
k_i ({}^Mb_{i,x}\hat{s}_{i,y} - {}^Mb_{i,y}\hat{s}_{i,x}) \hat{s}_i = {}^MO_{K,x} k_i \hat{s}_{i,y} \hat{s}_i -  {}^MO_{K,y} k_i \hat{s}_{i,x} \hat{s}_i
\end{equation}

And we have two sets of linear equations of two unknowns.

This can be easily solved by writing the equations in a matrix form:
\begin{equation}
\underbrace{k_i ({}^Mb_{i,x}\hat{s}_{i,y} - {}^Mb_{i,y}\hat{s}_{i,x}) \hat{s}_i}_{2 \times 1} =
\underbrace{\begin{bmatrix}
& \\
k_i \hat{s}_{i,y} \hat{s}_i & - k_i \hat{s}_{i,x} \hat{s}_i \\
& \\
\end{bmatrix}}_{2 \times 2}
\underbrace{\begin{bmatrix}
{}^MO_{K,x}\\
{}^MO_{K,y}
\end{bmatrix}}_{2 \times 1}
\end{equation}

And finally, if the matrix is invertible:
\begin{equation}
\boxed{
{}^MO_K = {\begin{bmatrix}
& \\
k_i \hat{s}_{i,y} \hat{s}_i & - k_i \hat{s}_{i,x} \hat{s}_i \\
& \\
\end{bmatrix}}^{-1} k_i ({}^Mb_{i,x}\hat{s}_{i,y} - {}^Mb_{i,y}\hat{s}_{i,x}) \hat{s}_i
}
\end{equation}

Note that a rotation of the frame $\{K\}$ with respect to frame $\{M\}$ would make not change on the "diagonality" of $K_{\{K\}}$.

** Example 1 - Planar manipulator with 3 actuators
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

Consider system of Figure [[fig:3dof_model_fully_parallel_example]].

#+name: fig:3dof_model_fully_parallel_example
#+caption: Example of 3DoF parallel platform
[[file:figs/3dof_model_fully_parallel.png]]

The stiffnesses $k_i$, the joint positions ${}^Mb_i$ and joint unit vectors ${}^M\hat{s}_i$ are defined below:
#+begin_src matlab
ki = [5,1,2]; % Stiffnesses [N/m]
si = [[1;0],[0;1],[0;1]]; si = si./vecnorm(si); % Unit Vectors
bi = [[-1;0.5],[-2;-1],[0;-1]]; % Joint's positions in frame {M}
#+end_src

Let's first verify that condition eqref:eq:diag_cond_2D_1 is true:
#+begin_src matlab :results value replace :exports results
ki.*si*si'
#+end_src

#+RESULTS:
| 5 | 0 |
| 0 | 2 |

Now, compute ${}^MO_K$:
#+begin_src matlab
Ok = inv([sum(ki.*si(2,:).*si, 2), -sum(ki.*si(1,:).*si, 2)])*sum(ki.*(bi(1,:).*si(2,:) - bi(2,:).*si(1,:)).*si, 2);
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Ok
#+end_src

#+RESULTS:
|  -1 |
| 0.5 |

Let's compute the new coordinates ${}^Kb_i$ after the change of frame:
#+begin_src matlab
Kbi = bi - Ok;
#+end_src

In order to verify that the new frame $\{K\}$ indeed yields a diagonal stiffness matrix, we first compute the Jacobian $J_{\{K\}}$:
#+begin_src matlab
Jk = [si', (Kbi(1,:).*si(2,:) - Kbi(2,:).*si(1,:))'];
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Jk
#+end_src

#+RESULTS:
| 1 | 0 |  0 |
| 0 | 1 | -1 |
| 0 | 1 |  1 |

And the stiffness matrix:
#+begin_src matlab
K = Jk'*diag(ki)*Jk
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = K
#+end_src

#+RESULTS:
| 5 | 0 | 0 |
| 0 | 2 | 0 |
| 0 | 0 | 2 |

** Example 2 - Planar manipulator with 4 actuators
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

Now consider the planar manipulator of Figure [[fig:model_planar_2]].

#+name: fig:model_planar_2
#+caption: Planar Manipulator
#+attr_latex: :width 0.8\linewidth
[[file:figs/model_planar_2.png]]

The stiffnesses $k_i$, the joint positions ${}^Mb_i$ and joint unit vectors ${}^M\hat{s}_i$ are defined below:
#+begin_src matlab
ki = [1,2,1,1];
si = [[1;0],[0;1],[-1;0],[0;1]];
si = si./vecnorm(si);
h = 0.2;
L = 2;
bi = [[-L/2;h],[-L/2;-h],[L/2;h],[L/2;h]];
#+end_src

Let's first verify that condition eqref:eq:diag_cond_2D_1 is true:
#+begin_src matlab :results value replace :exports both
ki.*si*si'
#+end_src

#+RESULTS:
| 2 | 0 |
| 0 | 3 |

Now, compute ${}^MO_K$:
#+begin_src matlab
Ok = inv([sum(ki.*si(2,:).*si, 2), -sum(ki.*si(1,:).*si, 2)])*sum(ki.*(bi(1,:).*si(2,:) - bi(2,:).*si(1,:)).*si, 2);
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Ok
#+end_src

#+RESULTS:
| -0.33333 |
|      0.2 |

Let's compute the new coordinates ${}^Kb_i$ after the change of frame:
#+begin_src matlab
Kbi = bi - Ok;
#+end_src

In order to verify that the new frame $\{K\}$ indeed yields a diagonal stiffness matrix, we first compute the Jacobian $J_{\{K\}}$:
#+begin_src matlab
Jk = [si', (Kbi(1,:).*si(2,:) - Kbi(2,:).*si(1,:))'];
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Jk
#+end_src

#+RESULTS:
|  1 | 0 |        0 |
|  0 | 1 | -0.66667 |
| -1 | 0 |        0 |
|  0 | 1 |   1.3333 |

And the stiffness matrix:
#+begin_src matlab
K = Jk'*diag(ki)*Jk
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = K
#+end_src

#+RESULTS:
| 2 |           0 |           0 |
| 0 |           3 | -2.2204e-16 |
| 0 | -2.2204e-16 |      2.6667 |

* Diagonal Stiffness Matrix for a general parallel manipulator
** Model and Assumptions
Let's consider a 6dof parallel manipulator with:
- $b_i$: location of the joints on the top platform are called $b_i$
- $\hat{s}_i$: unit vector corresponding to the struts
- $k_i$: stiffness of the struts
- $\tau_i$: actuator forces
- $O_M$: center of mass of the solid body

Consider two frames:
- $\{M\}$ with origin $O_M$
- $\{K\}$ with origin $O_K$

An example is shown in Figure [[fig:stewart_architecture_example]].

#+name: fig:stewart_architecture_example
#+caption: Parallel manipulator Example
[[file:figs/stewart_architecture_example.png]]

** Objective

The objective is to find conditions for the existence of a frame $\{K\}$ in which the Stiffness matrix of the manipulator is diagonal.
If the conditions are fulfilled, a second objective is to fine the location of the frame $\{K\}$ analytically.

** Analytical formula of the stiffness matrix
For a fully parallel manipulator, the stiffness matrix $K_{\{K\}}$ expressed in a frame $\{K\}$ is:
\begin{equation}
  K_{\{K\}} = J_{\{K\}}^T \mathcal{K} J_{\{K\}}
\end{equation}
where:
- $J_{\{K\}}$ is the Jacobian transformation from the struts to the frame $\{K\}$
- $\mathcal{K}$ is a diagonal matrix with the strut stiffnesses on the diagonal:
  \begin{equation}
  \mathcal{K} = \begin{bmatrix}
    k_1 &     &        & 0 \\
        & k_2 &        &   \\
        &     & \ddots &   \\
    0   &     &        & k_n
  \end{bmatrix}
  \end{equation}


The analytical expression of $J_{\{K\}}$ is:
\begin{equation}
J_{\{K\}} = \begin{bmatrix}
  {}^K\hat{s}_1^T & ({}^Kb_1 \times {}^K\hat{s}_1)^T \\
  {}^K\hat{s}_2^T & ({}^Kb_2 \times {}^K\hat{s}_2)^T \\
  \vdots          & \vdots                            \\
  {}^K\hat{s}_n^T & ({}^Kb_n \times {}^K\hat{s}_n)^T
\end{bmatrix}
\end{equation}

To simplify, we ignore the superscript $K$ and we assume that all vectors / positions are expressed in this frame $\{K\}$.
Otherwise, it is explicitly written.

Let's now write the analytical expressing of the stiffness matrix $K_{\{K\}}$:
\begin{equation}
K_{\{K\}} = \begin{bmatrix}
  \hat{s}_1              & \dots & \hat{s}_n \\
  (b_1 \times \hat{s}_1) & \dots & (b_n \times \hat{s}_n)
\end{bmatrix}
\begin{bmatrix}
  k_1 & & \\
      & \ddots & \\
      & & k_n
\end{bmatrix}
\begin{bmatrix}
  \hat{s}_1^T & (b_1 \times \hat{s}_1)^T \\
  \hat{s}_2^T & (b_2 \times \hat{s}_2)^T \\
  \vdots          & \dots                            \\
  \hat{s}_n^T & (b_n \times \hat{s}_n)^T
\end{bmatrix}
\end{equation}

And we finally obtain:
\begin{equation}
\boxed{
K_{\{K\}} = \left[ \begin{array}{c|c}
  k_i \hat{s}_i \hat{s}_i^T              & k_i \hat{s}_i (b_i \times \hat{s}_i)^T \cr
  \hline
  k_i (b_i \times \hat{s}_i) \hat{s}_i^T & k_i (b_i \times \hat{s}_i) (b_i \times \hat{s}_i)^T
\end{array} \right]
}
\end{equation}

We want the stiffness matrix to be diagonal, therefore, we have the following conditions:
\begin{align}
k_i \hat{s}_i \hat{s}_i^T &= \text{diag. matrix} \label{eq:diag_cond_1} \\
k_i (b_i \times \hat{s}_i) (b_i \times \hat{s}_i)^T &= \text{diag. matrix} \label{eq:diag_cond_2} \\
k_i \hat{s}_i (b_i \times \hat{s}_i)^T &= 0 \label{eq:diag_cond_3}
\end{align}

Note that:
- condition eqref:eq:diag_cond_1 corresponds to coupling between forces applied on $O_K$ to translations of the payload.
  It does not depend on the choice of $\{K\}$, it only depends on the orientation of the struts and the stiffnesses.
  It is therefore an intrinsic property of the manipulator.
- condition eqref:eq:diag_cond_2 corresponds to the coupling between forces applied on $O_K$ and rotation of the payload.
  Similarly, it does also correspond to the coupling between torques applied on $O_K$ to translations of the payload.
- condition eqref:eq:diag_cond_3 corresponds to the coupling between torques applied on $O_K$ to rotation of the payload.
- conditions eqref:eq:diag_cond_2 and eqref:eq:diag_cond_3 do depend on the positions ${}^Kb_i$ and therefore depend on the choice of $\{K\}$.

Note that if we find a frame $\{K\}$ in which the stiffness matrix $K_{\{K\}}$ is diagonal, it will still be diagonal for any rotation of the frame $\{K\}$.
Therefore, we here suppose that the frame $\{K\}$ is aligned with the initial frame $\{M\}$.

Let's make a change of frame from the initial frame $\{M\}$ to the frame $\{K\}$:
\begin{align}
{}^Kb_i &= {}^Mb_i - {}^MO_K \\
{}^K\hat{s}_i &= {}^M\hat{s}_i
\end{align}

The goal is to find ${}^MO_K$ such that conditions eqref:eq:diag_cond_2 and eqref:eq:diag_cond_3 are fulfilled.

Let's first solve equation eqref:eq:diag_cond_3 that corresponds to the coupling between forces and rotations:
\begin{equation}
k_i \hat{s}_i (({}^Mb_i - {}^MO_K) \times \hat{s}_i)^T = 0
\end{equation}

Taking the transpose and re-arranging:
\begin{equation}
k_i ({}^Mb_i \times \hat{s}_i) \hat{s}_i^T = k_i ({}^MO_K \times \hat{s}_i) \hat{s}_i^T
\end{equation}

As the vector cross product also can be expressed as the product of a skew-symmetric matrix and a vector, we obtain:
\begin{equation}
k_i ({}^Mb_i \times \hat{s}_i) \hat{s}_i^T = {}^M\bm{O}_{K} ( k_i \hat{s}_i \hat{s}_i^T )
\end{equation}

with:
\begin{equation} \label{eq:skew_symmetric_cross_product}
{}^M\bm{O}_K = \begin{bmatrix}
0 & -{}^MO_{K,z} & {}^MO_{K,y} \\
{}^MO_{K,z} & 0 & -{}^MO_{K,x} \\
-{}^MO_{K,y} & {}^MO_{K,x} & 0
\end{bmatrix}
\end{equation}

We suppose $k_i \hat{s}_i \hat{s}_i^T$ invertible as it is diagonal from eqref:eq:diag_cond_1.

And finally, we find:
\begin{equation}
\boxed{
{}^M\bm{O}_{K} = \left( k_i ({}^Mb_i \times \hat{s}_i) \hat{s}_i^T\right) \cdot {\left( k_i \hat{s}_i \hat{s}_i^T \right)}^{-1}
}
\end{equation}

If the obtained ${}^M\bm{O}_{K}$ is a skew-symmetric matrix, we can easily determine the corresponding vector ${}^MO_K$ from eqref:eq:skew_symmetric_cross_product.

In such case, condition eqref:eq:diag_cond_2 is fulfilled and there is no coupling between translations and rotations in the frame $\{K\}$.

Then, we can only verify if condition eqref:eq:diag_cond_3 is verified or not.

#+begin_note
If there is no frame $\{K\}$ such that conditions eqref:eq:diag_cond_2 and eqref:eq:diag_cond_3 are valid, it would be interesting to be able to determine the frame $\{K\}$ in which is coupling is minimal.
#+end_note

** Example 1 - 6DoF manipulator (3D)
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

Let's define the geometry of the manipulator (${}^Mb_i$, ${}^Ms_i$ and $k_i$):
#+begin_src matlab
ki = [2,2,1,1,3,3,1,1,1,1,2,2];
si = [[-1;0;0],[-1;0;0],[-1;0;0],[-1;0;0],[0;0;1],[0;0;1],[0;0;1],[0;0;1],[0;-1;0],[0;-1;0],[0;-1;0],[0;-1;0]];
bi = [[1;-1;1],[1;1;-1],[1;1;1],[1;-1;-1],[1;-1;-1],[-1;1;-1],[1;1;-1],[-1;-1;-1],[1;1;-1],[-1;1;1],[-1;1;-1],[1;1;1]]-[0;2;-1];
#+end_src

Cond 1:
#+begin_src matlab :results value replace :exports both
ki.*si*si'
#+end_src

#+RESULTS:
| 6 | 0 | 0 |
| 0 | 6 | 0 |
| 0 | 0 | 8 |

Find Ok
#+begin_src matlab
OkX = (ki.*cross(bi, si)*si')/(ki.*si*si');

if all(diag(OkX) == 0) && all(all((OkX + OkX') == 0))
    disp('OkX is skew symmetric')
    Ok = [OkX(3,2);OkX(1,3);OkX(2,1)]
else
    error('OkX is *not* skew symmetric')
end
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Ok
#+end_src

#+RESULTS:
|  0 |
| -2 |
|  1 |

#+begin_src matlab :results value replace
% Verification of second condition
si*cross(bi-Ok, si)'
#+end_src

#+RESULTS:
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

Verification of third condition
#+begin_src matlab :results value replace
ki.*cross(bi-Ok, si)*cross(bi-Ok, si)'
#+end_src

#+RESULTS:
| 14 |  4 | -2 |
|  4 | 14 |  2 |
| -2 |  2 | 12 |

Let's compute the Jacobian:
#+begin_src matlab
Jk = [si', cross(bi - Ok, si)'];
#+end_src

And the stiffness matrix:
#+begin_src matlab :results value replace
Jk'*diag(ki)*Jk
#+end_src

#+RESULTS:
| 6 | 0 | 0 |  0 |  0 |  0 |
| 0 | 6 | 0 |  0 |  0 |  0 |
| 0 | 0 | 8 |  0 |  0 |  0 |
| 0 | 0 | 0 | 14 |  4 | -2 |
| 0 | 0 | 0 |  4 | 14 |  2 |
| 0 | 0 | 0 | -2 |  2 | 12 |

#+begin_src matlab
figure;
hold on;
set(gca,'ColorOrderIndex',1)
plot(b1(1), b1(2), 'o');
set(gca,'ColorOrderIndex',2)
plot(b2(1), b2(2), 'o');
set(gca,'ColorOrderIndex',3)
plot(b3(1), b3(2), 'o');
set(gca,'ColorOrderIndex',1)
quiver(b1(1),b1(2),0.1*s1(1),0.1*s1(2))
set(gca,'ColorOrderIndex',2)
quiver(b2(1),b2(2),0.1*s2(1),0.1*s2(2))
set(gca,'ColorOrderIndex',3)
quiver(b3(1),b3(2),0.1*s3(1),0.1*s3(2))

plot(0, 0, 'ko');
quiver([0,0],[0,0],[0.1,0],[0,0.1], 'k')

plot(Ok(1), Ok(2), 'ro');
quiver([Ok(1),Ok(1)],[Ok(2),Ok(2)],[0.1,0],[0,0.1], 'r')

hold off;
axis equal;
#+end_src

** TODO Example 2 - Stewart Platform
* Stiffness and Mass Matrices in the Leg's frame

** Equations
Equations in the $\{M\}$ frame:
\begin{equation}
\left( M_{\{M\}} s^2 + K_{\{M\}} \right) \mathcal{X}_{\{M\}} = \mathcal{F}_{\{M\}}
\end{equation}

Thank to the Jacobian, we can transform the equation of motion expressed in the $\{M\}$ frame to the frame of the legs:
\begin{equation}
J_{\{M\}}^{-T} \left( M_{\{M\}} s^2 + K_{\{M\}} \right) J_{\{M\}}^{-1} \dot{\mathcal{L}} = \tau
\end{equation}

And we have new stiffness and mass matrices:
\begin{equation}
\left( M_{\{L\}} s^2 + K_{\{L\}} \right) \dot{\mathcal{L}} = \tau
\end{equation}
with:
- The local mass matrix:
  \[ M_{\{L\}} = J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} \]
- The local stiffness matrix:
  \[ K_{\{L\}} = J_{\{M\}}^{-T} K_{\{M\}} J_{\{M\}}^{-1} \]

** Stiffness matrix
We have that:
\[ K_{\{M\}} = J_{\{M\}}^T \mathcal{K} J_{\{M\}} \]

Therefore, we find that $K_{\{L\}}$ is a diagonal matrix:
\begin{equation}
K_{\{L\}} = \mathcal{K} = \begin{bmatrix}
k_1 & & 0 \\
 & \ddots & \\
0 & & k_n
\end{bmatrix}
\end{equation}

The dynamics from $\tau$ to $\mathcal{L}$ is therefore decoupled at low frequency.

** Mass matrix
The mass matrix in the frames of the legs is:
\[ M_{\{L\}} = J_{\{M\}}^{-T} M_{\{M\}} J_{\{M\}}^{-1} \]
with $M_{\{M\}}$ a diagonal matrix:
\begin{equation}
M_{\{M\}} = \begin{bmatrix}
m &   &   &     &     & \\
  & m &   &     & 0   & \\
  &   & m &     &     & \\
  &   &   & I_x &     & \\
  & 0 &   &     & I_y & \\
  &   &   &     &     & I_z
\end{bmatrix}
\end{equation}

Let's suppose $M_{\{L\}} = \mathcal{M}$ diagonal and try to find what does this imply:
\[ M_{\{M\}} = J_{\{M\}}^{T} \mathcal{M} J_{\{M\}} \]
with:
\begin{equation}
\mathcal{M} = \begin{bmatrix}
m_1 & & 0 \\
 & \ddots & \\
0 & & m_n
\end{bmatrix}
\end{equation}

We obtain:
\begin{equation}
\boxed{
M_{\{M\}} = \left[ \begin{array}{c|c}
  m_i \hat{s}_i \hat{s}_i^T              & m_i \hat{s}_i (b_i \times \hat{s}_i)^T \cr
  \hline
  k_i \hat{s}_i (b_i \times \hat{s}_i)^T & m_i (b_i \times \hat{s}_i) (b_i \times \hat{s}_i)^T
\end{array} \right]
}
\end{equation}

Therefore, we have the following conditions:
\begin{align}
m_i \hat{s}_i \hat{s}_i^T &= m \bm{I}_{3} \\
m_i \hat{s}_i (b_i \times \hat{s}_i)^T &= \bm{O}_{3} \\
m_i (b_i \times \hat{s}_i) (b_i \times \hat{s}_i)^T &= \text{diag}(I_x, I_y, I_z)
\end{align}


** Planar Example
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

The stiffnesses $k_i$, the joint positions ${}^Mb_i$ and joint unit vectors ${}^M\hat{s}_i$ are defined below:
#+begin_src matlab
ki = [1,1,1]; % Stiffnesses [N/m]
si = [[1;0],[0;1],[0;1]]; si = si./vecnorm(si); % Unit Vectors
bi = [[-1; 0],[-10;-1],[0;-1]]; % Joint's positions in frame {M}
#+end_src

Jacobian in frame $\{M\}$:
#+begin_src matlab
Jm = [si', (bi(1,:).*si(2,:) - bi(2,:).*si(1,:))'];
#+end_src

And the stiffness matrix in frame $\{K\}$:
#+begin_src matlab
Km = Jm'*diag(ki)*Jm;
#+end_src

#+begin_src matlab :results value replace :exports results :tangle no
ans = Km
#+end_src

#+RESULTS:
| 2 |  0 |  1 |
| 0 |  1 | -1 |
| 1 | -1 |  2 |

Mass matrix in the frame $\{M\}$:
#+begin_src matlab
m = 10; % [kg]
I = 1; % [kg.m^2]

Mm = diag([m, m, I]);
#+end_src


Now compute $K$ and $M$ in the frame of the legs:
#+begin_src matlab
ML = inv(Jm)'*Mm*inv(Jm)
KL = inv(Jm)'*Km*inv(Jm)
#+end_src

#+begin_src matlab
Gm = 1/(ML*s^2 + KL);
#+end_src

#+begin_src matlab
freqs = logspace(-2, 1, 1000);
figure;
hold on;
for i = 1:length(ki)
    plot(freqs, abs(squeeze(freqresp(Gm(i,i), freqs, 'Hz'))), 'k-')
end
for i = 1:length(ki)
    for j = i+1:length(ki)
        plot(freqs, abs(squeeze(freqresp(Gm(i,j), freqs, 'Hz'))), 'r-')
    end
end
hold off;
xlabel('Frequency [Hz]');
ylabel('Magnitude');
set(gca, 'xscale', 'log');
set(gca, 'yscale', 'log');
#+end_src

* Stewart Platform - Simscape Model
:PROPERTIES:
:header-args:matlab+: :tangle stewart_platform/script.m
:END:
<<sec:stewart_platform>>

** Introduction                                                      :ignore:

In this analysis, we wish to applied SVD control to the Stewart Platform shown in Figure [[fig:SP_assembly]].

Some notes about the system:
- 6 voice coils actuators are used to control the motion of the top platform.
- the motion of the top platform is measured with a 6-axis inertial unit (3 acceleration + 3 angular accelerations)
- the control objective is to isolate the top platform from vibrations coming from the bottom platform

#+name: fig:SP_assembly
#+caption: Stewart Platform CAD View
[[file:figs/SP_assembly.png]]

The analysis of the SVD/Jacobian control applied to the Stewart platform is performed in the following sections:
- Section [[sec:stewart_simscape]]: The parameters of the Simscape model of the Stewart platform are defined
- Section [[sec:stewart_identification]]: The plant is identified from the Simscape model and the system coupling is shown
- Section [[sec:stewart_jacobian_decoupling]]: The plant is first decoupled using the Jacobian
- Section [[sec:stewart_svd_decoupling]]: The decoupling is performed thanks to the SVD. To do so a real approximation of the plant is computed.
- Section [[sec:stewart_gershorin_radii]]: The effectiveness of the decoupling with the Jacobian and SVD are compared using the Gershorin Radii
- Section [[sec:stewart_rga]]:
- Section [[sec:stewart_decoupled_plant]]: The dynamics of the decoupled plants are shown
- Section [[sec:stewart_diagonal_control]]: A diagonal controller is defined to control the decoupled plant
- Section [[sec:stewart_closed_loop_results]]: Finally, the closed loop system properties are studied

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
<<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
<<matlab-init>>
#+end_src

#+begin_src matlab :tangle no
addpath('stewart_platform');
addpath('stewart_platform/STEP');
#+end_src

#+begin_src matlab :eval no
addpath('STEP');
#+end_src

#+begin_src matlab
freqs = logspace(-1, 2, 1000);
#+end_src

** Jacobian                                                        :noexport:
First, the position of the "joints" (points of force application) are estimated and the Jacobian computed.
#+begin_src matlab :tangle no
open('drone_platform_jacobian.slx');
#+end_src

#+begin_src matlab :tangle no
sim('drone_platform_jacobian');
#+end_src

#+begin_src matlab :tangle no
Aa = [a1.Data(1,:);
      a2.Data(1,:);
      a3.Data(1,:);
      a4.Data(1,:);
      a5.Data(1,:);
      a6.Data(1,:)]';

Ab = [b1.Data(1,:);
      b2.Data(1,:);
      b3.Data(1,:);
      b4.Data(1,:);
      b5.Data(1,:);
      b6.Data(1,:)]';

As = (Ab - Aa)./vecnorm(Ab - Aa);

l = vecnorm(Ab - Aa)';

J = [As' , cross(Ab, As)'];

save('stewart_platform/jacobian.mat', 'Aa', 'Ab', 'As', 'l', 'J');
#+end_src

** Simscape Model - Parameters
<<sec:stewart_simscape>>
#+begin_src matlab
open('drone_platform.slx');
#+end_src

Definition of spring parameters:
#+begin_src matlab
kx = 0.5*1e3/3; % [N/m]
ky = 0.5*1e3/3;
kz = 1e3/3;

cx = 0.025; % [Nm/rad]
cy = 0.025;
cz = 0.025;
#+end_src

We suppose the sensor is perfectly positioned.
#+begin_src matlab
sens_pos_error = zeros(3,1);
#+end_src

Gravity:
#+begin_src matlab
g = 0;
#+end_src

We load the Jacobian (previously computed from the geometry):
#+begin_src matlab
load('jacobian.mat', 'Aa', 'Ab', 'As', 'l', 'J');
#+end_src

We initialize other parameters:
#+begin_src matlab
U = eye(6);
V = eye(6);
Kc = tf(zeros(6));
#+end_src

#+name: fig:stewart_simscape
#+attr_latex: :width \linewidth
#+caption: General view of the Simscape Model
[[file:figs/stewart_simscape.png]]

#+name: fig:stewart_platform_details
#+attr_latex: :width \linewidth
#+caption: Simscape model of the Stewart platform
[[file:figs/stewart_platform_details.png]]

** Identification of the plant
<<sec:stewart_identification>>

The plant shown in Figure [[fig:stewart_platform_plant]] is identified from the Simscape model.

The inputs are:
- $D_w$ translation and rotation of the bottom platform (with respect to the center of mass of the top platform)
- $\tau$ the 6 forces applied by the voice coils

The outputs are the 6 accelerations measured by the inertial unit.

#+begin_src latex :file stewart_platform_plant.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block={2cm}{1.5cm}] (G) {$\begin{bmatrix}G_d\\G_u\end{bmatrix}$};
  \node[above] at (G.north) {$\bm{G}$};

  % Inputs of the controllers
  \coordinate[] (inputd) at ($(G.south west)!0.75!(G.north west)$);
  \coordinate[] (inputu) at ($(G.south west)!0.25!(G.north west)$);
  % Connections and labels

  \draw[<-] (inputd) -- ++(-0.8, 0) node[above right]{$D_w$};
  \draw[<-] (inputu) -- ++(-0.8, 0) node[above right]{$\tau$};
  \draw[->] (G.east) -- ++(0.8, 0)  node[above left]{$a$};
\end{tikzpicture}
#+end_src

#+name: fig:stewart_platform_plant
#+caption: Considered plant $\bm{G} = \begin{bmatrix}G_d\\G_u\end{bmatrix}$. $D_w$ is the translation/rotation of the support, $\tau$ the actuator forces, $a$ the acceleration/angular acceleration of the top platform
#+RESULTS:
[[file:figs/stewart_platform_plant.png]]

#+begin_src matlab
%% Name of the Simulink File
mdl = 'drone_platform';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/Dw'],              1, 'openinput');  io_i = io_i + 1; % Ground Motion
io(io_i) = linio([mdl, '/V-T'],             1, 'openinput');  io_i = io_i + 1; % Actuator Forces
io(io_i) = linio([mdl, '/Inertial Sensor'], 1, 'openoutput'); io_i = io_i + 1; % Top platform acceleration

G = linearize(mdl, io);
G.InputName  = {'Dwx', 'Dwy', 'Dwz', 'Rwx', 'Rwy', 'Rwz', ...
                'F1', 'F2', 'F3', 'F4', 'F5', 'F6'};
G.OutputName = {'Ax', 'Ay', 'Az', 'Arx', 'Ary', 'Arz'};

% Plant
Gu = G(:, {'F1', 'F2', 'F3', 'F4', 'F5', 'F6'});
% Disturbance dynamics
Gd = G(:, {'Dwx', 'Dwy', 'Dwz', 'Rwx', 'Rwy', 'Rwz'});
#+end_src

There are 24 states (6dof for the bottom platform + 6dof for the top platform).
#+begin_src matlab :results output replace
size(G)
#+end_src

#+RESULTS:
: State-space model with 6 outputs, 12 inputs, and 24 states.

The elements of the transfer matrix $\bm{G}$ corresponding to the transfer function from actuator forces $\tau$ to the measured acceleration $a$ are shown in Figure [[fig:stewart_platform_coupled_plant]].

One can easily see that the system is strongly coupled.

#+begin_src matlab :exports none
figure;

% Magnitude
hold on;
for i_in = 1:6
    for i_out = [1:i_in-1, i_in+1:6]
        plot(freqs, abs(squeeze(freqresp(Gu(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gu(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
     'DisplayName', '$G_u(i,j)\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for i_in_out = 1:6
    plot(freqs, abs(squeeze(freqresp(Gu(i_in_out, i_in_out), freqs, 'Hz'))), 'DisplayName', sprintf('$G_u(%d,%d)$', i_in_out, i_in_out));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); ylabel('Magnitude');
ylim([1e-2, 1e5]);
legend('location', 'northwest');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/stewart_platform_coupled_plant.pdf', 'eps', true, 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:stewart_platform_coupled_plant
#+caption: Magnitude of all 36 elements of the transfer function matrix $G_u$
#+RESULTS:
[[file:figs/stewart_platform_coupled_plant.png]]

** Decoupling using the Jacobian
<<sec:stewart_jacobian_decoupling>>
Consider the control architecture shown in Figure [[fig:plant_decouple_jacobian]].
The Jacobian matrix is used to transform forces/torques applied on the top platform to the equivalent forces applied by each actuator.

The Jacobian matrix is computed from the geometry of the platform (position and orientation of the actuators).

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(J, {}, {}, ' %.3f ');
#+end_src

#+caption: Computed Jacobian Matrix
#+RESULTS:
|  0.811 |    0.0 | 0.584 | -0.018 | -0.008 |  0.025 |
| -0.406 | -0.703 | 0.584 | -0.016 | -0.012 | -0.025 |
| -0.406 |  0.703 | 0.584 |  0.016 | -0.012 |  0.025 |
|  0.811 |    0.0 | 0.584 |  0.018 | -0.008 | -0.025 |
| -0.406 | -0.703 | 0.584 |  0.002 |  0.019 |  0.025 |
| -0.406 |  0.703 | 0.584 | -0.002 |  0.019 | -0.025 |

#+begin_src latex :file plant_decouple_jacobian.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$G_u$};
  \node[block, left=0.6 of G] (J) {$J^{-T}$};

  % Connections and labels
  \draw[<-] (J.west) -- ++(-1.0, 0) node[above right]{$\mathcal{F}$};
  \draw[->] (J.east) -- (G.west)  node[above left]{$\tau$};
  \draw[->] (G.east) -- ++( 1.0, 0)  node[above left]{$a$};

  \begin{scope}[on background layer]
    \node[fit={(J.south west) (G.north east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gx) {};
    \node[below right] at (Gx.north west) {$\bm{G}_x$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:plant_decouple_jacobian
#+caption: Decoupled plant $\bm{G}_x$ using the Jacobian matrix $J$
#+RESULTS:
[[file:figs/plant_decouple_jacobian.png]]

We define a new plant:
\[ G_x(s) = G(s) J^{-T} \]

$G_x(s)$ correspond to the transfer function from forces and torques applied to the top platform to the absolute acceleration of the top platform.

#+begin_src matlab
Gx = Gu*inv(J');
Gx.InputName  = {'Fx', 'Fy', 'Fz', 'Mx', 'My', 'Mz'};
#+end_src

** Decoupling using the SVD
<<sec:stewart_svd_decoupling>>

In order to decouple the plant using the SVD, first a real approximation of the plant transfer function matrix as the crossover frequency is required.

Let's compute a real approximation of the complex matrix $H_1$ which corresponds to the the transfer function $G_u(j\omega_c)$ from forces applied by the actuators to the measured acceleration of the top platform evaluated at the frequency $\omega_c$.
#+begin_src matlab
wc = 2*pi*30; % Decoupling frequency [rad/s]

H1 = evalfr(Gu, j*wc);
#+end_src

The real approximation is computed as follows:
#+begin_src matlab
D = pinv(real(H1'*H1));
H1 = inv(D*real(H1'*diag(exp(j*angle(diag(H1*D*H1.'))/2))));
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(H1, {}, {}, ' %.1f ');
#+end_src

#+caption: Real approximate of $G$ at the decoupling frequency $\omega_c$
#+RESULTS:
|    4.4 |   -2.1 |   -2.1 |    4.4 |  -2.4 |   -2.4 |
|   -0.2 |   -3.9 |    3.9 |    0.2 |  -3.8 |    3.8 |
|    3.4 |    3.4 |    3.4 |    3.4 |   3.4 |    3.4 |
| -367.1 | -323.8 |  323.8 |  367.1 |  43.3 |  -43.3 |
| -162.0 | -237.0 | -237.0 | -162.0 | 398.9 |  398.9 |
|  220.6 | -220.6 |  220.6 | -220.6 | 220.6 | -220.6 |


Note that the plant $G_u$ at $\omega_c$ is already an almost real matrix.
This can be seen on the Bode plots where the phase is close to 1.
This can be verified below where only the real value of $G_u(\omega_c)$ is shown

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(real(evalfr(Gu, j*wc)), {}, {}, ' %.1f ');
#+end_src

#+caption: Real part of $G$ at the decoupling frequency $\omega_c$
#+RESULTS:
|    4.4 |   -2.1 |   -2.1 |    4.4 |  -2.4 |   -2.4 |
|   -0.2 |   -3.9 |    3.9 |    0.2 |  -3.8 |    3.8 |
|    3.4 |    3.4 |    3.4 |    3.4 |   3.4 |    3.4 |
| -367.1 | -323.8 |  323.8 |  367.1 |  43.3 |  -43.3 |
| -162.0 | -237.0 | -237.0 | -162.0 | 398.9 |  398.9 |
|  220.6 | -220.6 |  220.6 | -220.6 | 220.6 | -220.6 |

Now, the Singular Value Decomposition of $H_1$ is performed:
\[ H_1 = U \Sigma V^H \]

#+begin_src matlab
[U,~,V] = svd(H1);
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(U, {}, {}, ' %.1g ');
#+end_src

#+caption: Obtained matrix $U$
#+RESULTS:
| -0.005 |  7e-06 |  6e-11 | -3e-06 |     -1 |    0.1 |
| -7e-06 | -0.005 | -9e-09 | -5e-09 |   -0.1 |     -1 |
|  4e-08 | -2e-10 | -6e-11 |     -1 |  3e-06 | -3e-07 |
| -0.002 |     -1 | -5e-06 |  2e-10 | 0.0006 |  0.005 |
|      1 | -0.002 | -1e-08 |  2e-08 | -0.005 | 0.0006 |
| -4e-09 |  5e-06 |     -1 |  6e-11 | -2e-09 | -1e-08 |

#+begin_src matlab :exports results :results value table replace :tangle no
data2orgtable(V, {}, {}, ' %.1g ');
#+end_src

#+caption: Obtained matrix $V$
#+RESULTS:
| -0.2 |   0.5 | -0.4 | -0.4 |   -0.6 | -0.2 |
| -0.3 |   0.5 |  0.4 | -0.4 |    0.5 |  0.3 |
| -0.3 |  -0.5 | -0.4 | -0.4 |    0.4 | -0.4 |
| -0.2 |  -0.5 |  0.4 | -0.4 |   -0.5 |  0.3 |
|  0.6 | -0.06 | -0.4 | -0.4 |    0.1 |  0.6 |
|  0.6 |  0.06 |  0.4 | -0.4 | -0.006 | -0.6 |

The obtained matrices $U$ and $V$ are used to decouple the system as shown in Figure [[fig:plant_decouple_svd]].

#+begin_src latex :file plant_decouple_svd.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block] (G) {$G_u$};

  \node[block, left=0.6 of G.west] (V) {$V^{-T}$};
  \node[block, right=0.6 of G.east] (U) {$U^{-1}$};

  % Connections and labels
  \draw[<-] (V.west) -- ++(-1.0, 0) node[above right]{$u$};
  \draw[->] (V.east) -- (G.west) node[above left]{$\tau$};
  \draw[->] (G.east) -- (U.west) node[above left]{$a$};
  \draw[->] (U.east) -- ++( 1.0, 0) node[above left]{$y$};

  \begin{scope}[on background layer]
    \node[fit={(V.south west) (G.north-|U.east)}, fill=black!10!white, draw, dashed, inner sep=14pt] (Gsvd) {};
    \node[below right] at (Gsvd.north west) {$\bm{G}_{SVD}$};
  \end{scope}
\end{tikzpicture}
#+end_src

#+name: fig:plant_decouple_svd
#+caption: Decoupled plant $\bm{G}_{SVD}$ using the Singular Value Decomposition
#+RESULTS:
[[file:figs/plant_decouple_svd.png]]

The decoupled plant is then:
\[ G_{SVD}(s) = U^{-1} G_u(s) V^{-H} \]

#+begin_src matlab
Gsvd = inv(U)*Gu*inv(V');
#+end_src

** Verification of the decoupling using the "Gershgorin Radii"
<<sec:stewart_gershorin_radii>>

The "Gershgorin Radii" is computed for the coupled plant $G(s)$, for the "Jacobian plant" $G_x(s)$ and the "SVD Decoupled Plant" $G_{SVD}(s)$:

The "Gershgorin Radii" of a matrix $S$ is defined by:
\[ \zeta_i(j\omega) = \frac{\sum\limits_{j\neq i}|S_{ij}(j\omega)|}{|S_{ii}(j\omega)|} \]

This is computed over the following frequencies.
#+begin_src matlab :exports none
% Gershgorin Radii for the coupled plant:
Gr_coupled = zeros(length(freqs), size(Gu,2));
H = abs(squeeze(freqresp(Gu, freqs, 'Hz')));
for out_i = 1:size(Gu,2)
    Gr_coupled(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end

% Gershgorin Radii for the decoupled plant using SVD:
Gr_decoupled = zeros(length(freqs), size(Gsvd,2));
H = abs(squeeze(freqresp(Gsvd, freqs, 'Hz')));
for out_i = 1:size(Gsvd,2)
    Gr_decoupled(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end

% Gershgorin Radii for the decoupled plant using the Jacobian:
Gr_jacobian = zeros(length(freqs), size(Gx,2));
H = abs(squeeze(freqresp(Gx, freqs, 'Hz')));
for out_i = 1:size(Gx,2)
    Gr_jacobian(:, out_i) = squeeze((sum(H(out_i,:,:)) - H(out_i,out_i,:))./H(out_i, out_i, :));
end
#+end_src

#+begin_src matlab :exports results
figure;
hold on;
plot(freqs, Gr_coupled(:,1), 'DisplayName', 'Coupled');
plot(freqs, Gr_decoupled(:,1), 'DisplayName', 'SVD');
plot(freqs, Gr_jacobian(:,1), 'DisplayName', 'Jacobian');
for in_i = 2:6
    set(gca,'ColorOrderIndex',1)
    plot(freqs, Gr_coupled(:,in_i), 'HandleVisibility', 'off');
    set(gca,'ColorOrderIndex',2)
    plot(freqs, Gr_decoupled(:,in_i), 'HandleVisibility', 'off');
    set(gca,'ColorOrderIndex',3)
    plot(freqs, Gr_jacobian(:,in_i), 'HandleVisibility', 'off');
end
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
hold off;
xlabel('Frequency (Hz)'); ylabel('Gershgorin Radii')
legend('location', 'northwest');
ylim([1e-3, 1e3]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/simscape_model_gershgorin_radii.pdf', 'eps', true, 'width', 'wide', 'height', 'normal');
#+end_src

#+name: fig:simscape_model_gershgorin_radii
#+caption: Gershgorin Radii of the Coupled and Decoupled plants
#+RESULTS:
[[file:figs/simscape_model_gershgorin_radii.png]]

** Verification of the decoupling using the "Relative Gain Array"
<<sec:stewart_rga>>

The relative gain array (RGA) is defined as:
\begin{equation}
  \Lambda\big(G(s)\big) = G(s) \times \big( G(s)^{-1} \big)^T
\end{equation}
where $\times$ denotes an element by element multiplication and $G(s)$ is an $n \times n$ square transfer matrix.

The obtained RGA elements are shown in Figure [[fig:simscape_model_rga]].

#+begin_src matlab :exports none
% Relative Gain Array for the coupled plant:
RGA_coupled = zeros(length(freqs), size(Gu,1), size(Gu,2));
Gu_inv = inv(Gu);
for f_i = 1:length(freqs)
    RGA_coupled(f_i, :, :) = abs(evalfr(Gu, j*2*pi*freqs(f_i)).*evalfr(Gu_inv, j*2*pi*freqs(f_i))');
end

% Relative Gain Array for the decoupled plant using SVD:
RGA_svd = zeros(length(freqs), size(Gsvd,1), size(Gsvd,2));
Gsvd_inv = inv(Gsvd);
for f_i = 1:length(freqs)
    RGA_svd(f_i, :, :) = abs(evalfr(Gsvd, j*2*pi*freqs(f_i)).*evalfr(Gsvd_inv, j*2*pi*freqs(f_i))');
end

% Relative Gain Array for the decoupled plant using the Jacobian:
RGA_x = zeros(length(freqs), size(Gx,1), size(Gx,2));
Gx_inv = inv(Gx);
for f_i = 1:length(freqs)
    RGA_x(f_i, :, :) = abs(evalfr(Gx, j*2*pi*freqs(f_i)).*evalfr(Gx_inv, j*2*pi*freqs(f_i))');
end
#+end_src

#+begin_src matlab :exports none
figure;
tiledlayout(1, 2, 'TileSpacing', 'None', 'Padding', 'None');

ax1 = nexttile;
hold on;
for i_in = 1:6
    for i_out = [1:i_in-1, i_in+1:6]
        plot(freqs, RGA_svd(:, i_out, i_in), '--', 'color', [0 0 0 0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, RGA_svd(:, 1, 2), '--', 'color', [0 0 0 0.2], ...
     'DisplayName', '$RGA_{SVD}(i,j),\ i \neq j$');

plot(freqs, RGA_svd(:, 1, 1), 'k-', ...
     'DisplayName', '$RGA_{SVD}(i,i)$');
for ch_i = 1:6
    plot(freqs, RGA_svd(:, ch_i, ch_i), 'k-', ...
         'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); xlabel('Frequency [Hz]');
legend('location', 'southwest');

ax2 = nexttile;
hold on;
for i_in = 1:6
    for i_out = [1:i_in-1, i_in+1:6]
        plot(freqs, RGA_x(:, i_out, i_in), '--', 'color', [0 0 0 0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, RGA_x(:, 1, 2), '--', 'color', [0 0 0 0.2], ...
     'DisplayName', '$RGA_{X}(i,j),\ i \neq j$');

plot(freqs, RGA_x(:, 1, 1), 'k-', ...
     'DisplayName', '$RGA_{X}(i,i)$');
for ch_i = 1:6
    plot(freqs, RGA_x(:, ch_i, ch_i), 'k-', ...
         'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
xlabel('Frequency [Hz]'); set(gca, 'YTickLabel',[]);
legend('location', 'southwest');

linkaxes([ax1,ax2],'y');
xlim([1e-1, 1e3]); ylim([1e-5, 1e1]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/simscape_model_rga.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:simscape_model_rga
#+caption: Obtained norm of RGA elements for the SVD decoupled plant and the Jacobian decoupled plant
#+RESULTS:
[[file:figs/simscape_model_rga.png]]

** Obtained Decoupled Plants
<<sec:stewart_decoupled_plant>>

The bode plot of the diagonal and off-diagonal elements of $G_{SVD}$ are shown in Figure [[fig:simscape_model_decoupled_plant_svd]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
for i_in = 1:6
    for i_out = [1:i_in-1, i_in+1:6]
        plot(freqs, abs(squeeze(freqresp(Gsvd(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gsvd(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.5], ...
     'DisplayName', '$G_{SVD}(i,j),\ i \neq j$');
set(gca,'ColorOrderIndex',1)
for ch_i = 1:6
    plot(freqs, abs(squeeze(freqresp(Gsvd(ch_i, ch_i), freqs, 'Hz'))), ...
         'DisplayName', sprintf('$G_{SVD}(%i,%i)$', ch_i, ch_i));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'northwest');
ylim([1e-1, 1e5])

% Phase
ax2 = nexttile;
hold on;
for ch_i = 1:6
    plot(freqs, 180/pi*angle(squeeze(freqresp(Gsvd(ch_i, ch_i), freqs, 'Hz'))));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([-180, 180]);
yticks([-180:90:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/simscape_model_decoupled_plant_svd.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:simscape_model_decoupled_plant_svd
#+caption: Decoupled Plant using SVD
#+RESULTS:
[[file:figs/simscape_model_decoupled_plant_svd.png]]

Similarly, the bode plots of the diagonal elements and off-diagonal elements of the decoupled plant $G_x(s)$ using the Jacobian are shown in Figure [[fig:simscape_model_decoupled_plant_jacobian]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
for i_in = 1:6
    for i_out = [1:i_in-1, i_in+1:6]
        plot(freqs, abs(squeeze(freqresp(Gx(i_out, i_in), freqs, 'Hz'))), 'color', [0,0,0,0.2], ...
             'HandleVisibility', 'off');
    end
end
plot(freqs, abs(squeeze(freqresp(Gx(1, 2), freqs, 'Hz'))), 'color', [0,0,0,0.5], ...
     'DisplayName', '$G_x(i,j),\ i \neq j$');
set(gca,'ColorOrderIndex',1)
plot(freqs, abs(squeeze(freqresp(Gx('Ax', 'Fx'), freqs, 'Hz'))), 'DisplayName', '$G_x(1,1) = A_x/F_x$');
plot(freqs, abs(squeeze(freqresp(Gx('Ay', 'Fy'), freqs, 'Hz'))), 'DisplayName', '$G_x(2,2) = A_y/F_y$');
plot(freqs, abs(squeeze(freqresp(Gx('Az', 'Fz'), freqs, 'Hz'))), 'DisplayName', '$G_x(3,3) = A_z/F_z$');
plot(freqs, abs(squeeze(freqresp(Gx('Arx', 'Mx'), freqs, 'Hz'))), 'DisplayName', '$G_x(4,4) = A_{R_x}/M_x$');
plot(freqs, abs(squeeze(freqresp(Gx('Ary', 'My'), freqs, 'Hz'))), 'DisplayName', '$G_x(5,5) = A_{R_y}/M_y$');
plot(freqs, abs(squeeze(freqresp(Gx('Arz', 'Mz'), freqs, 'Hz'))), 'DisplayName', '$G_x(6,6) = A_{R_z}/M_z$');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'northwest');
ylim([1e-2, 2e6])

% Phase
ax2 = nexttile;
hold on;
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Ax', 'Fx'), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Ay', 'Fy'), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Az', 'Fz'), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Arx', 'Mx'), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Ary', 'My'), freqs, 'Hz'))));
plot(freqs, 180/pi*angle(squeeze(freqresp(Gx('Arz', 'Mz'), freqs, 'Hz'))));
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([0, 180]);
yticks([0:45:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/simscape_model_decoupled_plant_jacobian.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:simscape_model_decoupled_plant_jacobian
#+caption: Stewart Platform Plant from forces (resp. torques) applied by the legs to the acceleration (resp. angular acceleration) of the platform as well as all the coupling terms between the two (non-diagonal terms of the transfer function matrix)
#+RESULTS:
[[file:figs/simscape_model_decoupled_plant_jacobian.png]]

** Diagonal Controller
<<sec:stewart_diagonal_control>>
The control diagram for the centralized control is shown in Figure [[fig:centralized_control]].

The controller $K_c$ is "working" in an cartesian frame.
The Jacobian is used to convert forces in the cartesian frame to forces applied by the actuators.

#+begin_src latex :file centralized_control.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block={2cm}{1.5cm}] (G) {$\begin{bmatrix}G_d\\G_u\end{bmatrix}$};
  \node[above] at (G.north) {$\bm{G}$};
  \node[block, below right=0.6 and -0.5 of G] (K) {$K_c$};
  \node[block, below left= 0.6 and -0.5 of G] (J) {$J^{-T}$};

  % Inputs of the controllers
  \coordinate[] (inputd) at ($(G.south west)!0.75!(G.north west)$);
  \coordinate[] (inputu) at ($(G.south west)!0.25!(G.north west)$);

  % Connections and labels
  \draw[<-] (inputd) -- ++(-0.8, 0) node[above right]{$D_w$};
  \draw[->] (G.east) -- ++(2.0, 0)  node[above left]{$a$};
  \draw[->] ($(G.east)+(1.4, 0)$)node[branch]{} |- (K.east);
  \draw[->] (K.west) -- (J.east) node[above right]{$\mathcal{F}$};
  \draw[->] (J.west) -- ++(-0.6, 0) |- (inputu) node[above left]{$\tau$};
\end{tikzpicture}
#+end_src

#+name: fig:centralized_control
#+caption: Control Diagram for the Centralized control
#+RESULTS:
[[file:figs/centralized_control.png]]

The SVD control architecture is shown in Figure [[fig:svd_control]].
The matrices $U$ and $V$ are used to decoupled the plant $G$.

#+begin_src latex :file svd_control.pdf :tangle no :exports results
\begin{tikzpicture}
  \node[block={2cm}{1.5cm}] (G) {$\begin{bmatrix}G_d\\G_u\end{bmatrix}$};
  \node[above] at (G.north) {$\bm{G}$};
  \node[block, below right=0.6 and 0 of G] (U) {$U^{-1}$};
  \node[block, below=0.6 of G] (K) {$K_{\text{SVD}}$};
  \node[block, below left= 0.6 and 0 of G] (V) {$V^{-T}$};

  % Inputs of the controllers
  \coordinate[] (inputd) at ($(G.south west)!0.75!(G.north west)$);
  \coordinate[] (inputu) at ($(G.south west)!0.25!(G.north west)$);

  % Connections and labels
  \draw[<-] (inputd) -- ++(-0.8, 0) node[above right]{$D_w$};
  \draw[->] (G.east) -- ++(2.5, 0) node[above left]{$a$};
  \draw[->] ($(G.east)+(2.0, 0)$) node[branch]{} |- (U.east);
  \draw[->] (U.west) -- (K.east);
  \draw[->] (K.west) -- (V.east);
  \draw[->] (V.west) -- ++(-0.6, 0) |- (inputu) node[above left]{$\tau$};
\end{tikzpicture}
#+end_src

#+name: fig:svd_control
#+caption: Control Diagram for the SVD control
#+RESULTS:
[[file:figs/svd_control.png]]


We choose the controller to be a low pass filter:
\[ K_c(s) = \frac{G_0}{1 + \frac{s}{\omega_0}} \]

$G_0$ is tuned such that the crossover frequency corresponding to the diagonal terms of the loop gain is equal to $\omega_c$

#+begin_src matlab
wc = 2*pi*80;  % Crossover Frequency [rad/s]
w0 = 2*pi*0.1; % Controller Pole [rad/s]
#+end_src

#+begin_src matlab
K_cen = diag(1./diag(abs(evalfr(Gx, j*wc))))*(1/abs(evalfr(1/(1 + s/w0), j*wc)))/(1 + s/w0);
L_cen = K_cen*Gx;
G_cen = feedback(G, pinv(J')*K_cen, [7:12], [1:6]);
#+end_src

#+begin_src matlab
K_svd = diag(1./diag(abs(evalfr(Gsvd, j*wc))))*(1/abs(evalfr(1/(1 + s/w0), j*wc)))/(1 + s/w0);
L_svd = K_svd*Gsvd;
G_svd = feedback(G, inv(V')*K_svd*inv(U), [7:12], [1:6]);
#+end_src

The obtained diagonal elements of the loop gains are shown in Figure [[fig:stewart_comp_loop_gain_diagonal]].

#+begin_src matlab :exports none
figure;
tiledlayout(3, 1, 'TileSpacing', 'None', 'Padding', 'None');

% Magnitude
ax1 = nexttile([2, 1]);
hold on;
plot(freqs, abs(squeeze(freqresp(L_svd(1, 1), freqs, 'Hz'))), 'DisplayName', '$L_{SVD}(i,i)$');
for i_in_out = 2:6
    set(gca,'ColorOrderIndex',1)
    plot(freqs, abs(squeeze(freqresp(L_svd(i_in_out, i_in_out), freqs, 'Hz'))), 'HandleVisibility', 'off');
end

set(gca,'ColorOrderIndex',2)
plot(freqs, abs(squeeze(freqresp(L_cen(1, 1), freqs, 'Hz'))), ...
     'DisplayName', '$L_{J}(i,i)$');
for i_in_out = 2:6
    set(gca,'ColorOrderIndex',2)
    plot(freqs, abs(squeeze(freqresp(L_cen(i_in_out, i_in_out), freqs, 'Hz'))), 'HandleVisibility', 'off');
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('Magnitude'); set(gca, 'XTickLabel',[]);
legend('location', 'northwest');
ylim([5e-2, 2e3])

% Phase
ax2 = nexttile;
hold on;
for i_in_out = 1:6
    set(gca,'ColorOrderIndex',1)
    plot(freqs, 180/pi*angle(squeeze(freqresp(L_svd(i_in_out, i_in_out), freqs, 'Hz'))));
end
set(gca,'ColorOrderIndex',2)
for i_in_out = 1:6
    set(gca,'ColorOrderIndex',2)
    plot(freqs, 180/pi*angle(squeeze(freqresp(L_cen(i_in_out, i_in_out), freqs, 'Hz'))));
end
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
ylabel('Phase [deg]'); xlabel('Frequency [Hz]');
ylim([-180, 180]);
yticks([-180:90:360]);

linkaxes([ax1,ax2],'x');
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/stewart_comp_loop_gain_diagonal.pdf', 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:stewart_comp_loop_gain_diagonal
#+caption: Comparison of the diagonal elements of the loop gains for the SVD control architecture and the Jacobian one
#+RESULTS:
[[file:figs/stewart_comp_loop_gain_diagonal.png]]

** Closed-Loop system Performances
<<sec:stewart_closed_loop_results>>

Let's first verify the stability of the closed-loop systems:
#+begin_src matlab :results output replace text
isstable(G_cen)
#+end_src

#+RESULTS:
: ans =
:   logical
:    1

#+begin_src matlab :results output replace text
isstable(G_svd)
#+end_src

#+RESULTS:
: ans =
:   logical
:    1

The obtained transmissibility in Open-loop, for the centralized control as well as for the SVD control are shown in Figure [[fig:stewart_platform_simscape_cl_transmissibility]].

#+begin_src matlab :exports results
figure;
tiledlayout(2, 2, 'TileSpacing', 'None', 'Padding', 'None');

ax1 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Ax', 'Dwx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Open-Loop');
plot(freqs, abs(squeeze(freqresp(G_cen('Ax', 'Dwx')/s^2, freqs, 'Hz'))), 'DisplayName', 'Centralized');
plot(freqs, abs(squeeze(freqresp(G_svd('Ax', 'Dwx')/s^2, freqs, 'Hz'))), '--', 'DisplayName', 'SVD');
set(gca,'ColorOrderIndex',1)
plot(freqs, abs(squeeze(freqresp(G(    'Ay', 'Dwy')/s^2, freqs, 'Hz'))), 'HandleVisibility', 'off');
plot(freqs, abs(squeeze(freqresp(G_cen('Ay', 'Dwy')/s^2, freqs, 'Hz'))), 'HandleVisibility', 'off');
plot(freqs, abs(squeeze(freqresp(G_svd('Ay', 'Dwy')/s^2, freqs, 'Hz'))), '--', 'HandleVisibility', 'off');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('$D_x/D_{w,x}$, $D_y/D_{w, y}$'); set(gca, 'XTickLabel',[]);
legend('location', 'southwest');

ax2 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Az', 'Dwz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Az', 'Dwz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Az', 'Dwz')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('$D_z/D_{w,z}$'); set(gca, 'XTickLabel',[]);

ax3 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Arx', 'Rwx')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Arx', 'Rwx')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Arx', 'Rwx')/s^2, freqs, 'Hz'))), '--');
set(gca,'ColorOrderIndex',1)
plot(freqs, abs(squeeze(freqresp(G(    'Ary', 'Rwy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Ary', 'Rwy')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Ary', 'Rwy')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('$R_x/R_{w,x}$, $R_y/R_{w,y}$');  xlabel('Frequency [Hz]');

ax4 = nexttile;
hold on;
plot(freqs, abs(squeeze(freqresp(G(    'Arz', 'Rwz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_cen('Arz', 'Rwz')/s^2, freqs, 'Hz'))));
plot(freqs, abs(squeeze(freqresp(G_svd('Arz', 'Rwz')/s^2, freqs, 'Hz'))), '--');
hold off;
set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
ylabel('$R_z/R_{w,z}$');  xlabel('Frequency [Hz]');

linkaxes([ax1,ax2,ax3,ax4],'xy');
xlim([freqs(1), freqs(end)]);
ylim([1e-3, 1e2]);
#+end_src

#+begin_src matlab :tangle no :exports results :results file replace
exportFig('figs/stewart_platform_simscape_cl_transmissibility.pdf', 'eps', true, 'width', 'wide', 'height', 'tall');
#+end_src

#+name: fig:stewart_platform_simscape_cl_transmissibility
#+caption: Obtained Transmissibility
#+RESULTS:
[[file:figs/stewart_platform_simscape_cl_transmissibility.png]]

